<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1"
        />
        <meta name="description" content="A cozy little corner of the web." />
        <title>
            Dealing with Cyclic Data in Rust, Part I · Isaac Clayton
        </title>
        <link rel="preload stylesheet" href="/fonts.css" as="style" />
        <link rel="stylesheet" href="/reset.css" />
        <link rel="stylesheet" href="/base.css" />
        <link rel="stylesheet" href="/layout.css" />
        <link rel="icon" type="image/png" href="/icon.png" />
        <link rel="alternate" type="application/atom+xml" href="https://slightknack.dev/atom.xml" />
        <script data-goatcounter="https://slightknack.goatcounter.com/count"
                async src="//gc.zgo.at/count.js"></script>
        <!-- <script async defer type="text/javascript"
        src="https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js">
        </script> -->
        <!-- <script type="text/javascript" src="/elasticlunr.min.js" defer></script> -->
        <!-- <script type="text/javascript" src="/search_index.en.js" defer></script> -->
        <!-- <script type="text/javascript" src="/search.js" defer></script> -->

        <!-- maybe one day I'll bother to get these working... -->
        <!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/turbolinks/5.2.0/turbolinks.js"></script> -->
        <!-- <script type="module">
            import hotwiredTurbo from 'https://cdn.skypack.dev/@hotwired/turbo';
        </script> -->

         
    </head>

    <body style="overflow-x: hidden">
        
<!-- <div class="container"> -->
    <!-- <div class="sidebar">
    </div> -->
    <div class="content" id="top">
        <div class="narrow">
            <div class="navigation">
                <ul class="menu">
                      
                    <li class="pill">
                        <a class="tag" href="https:&#x2F;&#x2F;slightknack.dev&#x2F;about&#x2F;">
                             About 
                        </a>
                    </li>
                     
                    <li class="pill">
                        <a class="tag" href="https:&#x2F;&#x2F;slightknack.dev&#x2F;passerine&#x2F;">
                             Passerine 
                        </a>
                    </li>
                     
                    <li class="pill">
                        <a class="tag" href="https:&#x2F;&#x2F;slightknack.dev&#x2F;blog&#x2F;">
                             Blog 
                        </a>
                    </li>
                     
                    <li class="pill">
                        <a class="tag" href="https:&#x2F;&#x2F;slightknack.dev&#x2F;gallery&#x2F;">
                             Gallery 
                        </a>
                    </li>
                    
                    
<li class="pill">
    <a class="tag" href="https://goto.isaac.sh">Goto ↬</a>
</li>
<li class="pill">
    <a class="tag" href="https://stats.isaac.sh">Stats ↬</a>
</li>
<li class="pill">
    <a class="tag" href="https://git.isaac.sh">Github ↬</a>
</li>
<li class="pill">
    <a class="tag" href="https://slightknack.dev/atom.xml">RSS ↬</a>
</li>

                </ul>

                <div>

<a href="..">
    <div class="artbit">
        <img class="pixel-sidebar" src="/hypercard-artbits/bike.png" alt="Jump back up a level"/>
    </div>
</a>

</div>
            </div>

            <!-- <div class="text-input-container">
                <input
                    id="search"
                    type="search"
                    placeholder="Jump to..."
                    autocomplete="off"
                />
                <div class="search-results" style="display: none">
                    <div class="search-results__items"></div>
                </div>
            </div> -->

            
<!-- <div> -->
<h1 class="title" style="margin-top: 0;">Dealing with Cyclic Data in Rust, Part I</h1>
<p class="tag">2022-07-22 · About 20 minutes long</p>
<blockquote>
<p>Or, a <em>GhostCell Deep Dive</em>.</p>
<p>In this two-part series, we build <em>GhostCell</em> from first principles. In <em>Part I</em> we go over the underlying theory required to understand GhostCell. This post’s been sitting on my hard drive for about 9 months, so I’ve decided to bite the bullet, split what I’ve written in two, and hit publish on <em>Part I</em>. Hope you enjoy!</p>
</blockquote>
<p>Over the past month or so, something I’ve repeatedly run into is <em>GhostCell</em>, a technique that (ab)uses Rust’s lifetime system to detach ownership of data from the permission to mutate it. In short, this makes it possible to write datatypes that rely on shared interior mutability (think doubly-linked lists and other cyclical graph-like structures). In this post I wanted to explore Rust’s lifetime system to explain GhostCell from first principles, and why it’s kinda a big deal.</p>
<span id="continue-reading"></span><h1 id="on-memory-management">On memory management</h1>
<p>One of the reasons why I find Rust interesting is interesting because it automatically manages memory at compile time, as opposed to using a garbage collector or manual memory management. At the core of this automatic memory management is Rust’s <em>ownership model</em>, which is a compile-time strategy that ensures <em>memory safety</em>.</p>
<p>Memory safety boils down to two things:</p>
<ol>
<li>All allocated data is eventually freed once (a.k.a. deallocated, dropped).</li>
<li>All references to some data are gone before the data is dropped.</li>
</ol>
<p>Garbage Collected languages ensure this property is met by scanning large portions of the heap (at runtime!) to figure out which allocations are no longer alive. Traditional systems programming languages (think C, C++, asm) offload this work to the programmer, and thus do not <em>ensure</em> memory safety. Breaching the contract of memory safety can lead to hard-to-track-down bugs and severe security issues.</p>
<p>Rust’s ownership model essentially determines the <em>liveness</em> of data at compile time, built on the concept of <em>owned</em> and <em>borrowed</em> data. This model ensures memory safety with little to no runtime cost—so before we get started with GhostCell, I think we should start by addressing <em>ownership</em>.</p>
<h1 id="ownership">Ownership</h1>
<blockquote>
<p><strong>Note:</strong> This is a deep dive, so we do start with the basics. If you’d like, you can <a href="https://slightknack.dev/blog/rust-cycles/#subtyping">skip to the next section</a>.</p>
</blockquote>
<p>Newbies to Rust often find themselves ‘fighting the borrow checker.’ (We’ve all been there). In Rust, each bit of data has a single owner which is responsible for <em>dropping</em> (i.e. freeing) that data when it goes out of scope:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// x owns &quot;Hi&quot;
</span><span>println!(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, x);        </span><span style="color:#888888;">// prints &quot;Hi&quot;
</span><span style="color:#888888;">// x drops &quot;Hi&quot; at the end of the scope
</span></code></pre>
<p>In the above, <code>x</code> is the owner of <code>"Hi"</code>, and is responsible for dropping the value when it is no longer accessible.</p>
<p>Rust ensures that all data has exactly one owner (there’s an asterisk here, but we’ll get into that later). The following does not compile:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// x owns &quot;Hi&quot;
</span><span style="color:#8fbfdc;">let</span><span> y = x;                </span><span style="color:#888888;">// ownership of &quot;Hi&quot; moved from x to y
</span><span>println!(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, y);        </span><span style="color:#888888;">// prints &quot;Hi&quot;
</span><span>println!(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, x);        </span><span style="color:#888888;">// ERROR: &quot;Hi&quot; has been moved into y!
</span><span style="color:#888888;">// y drops &quot;Hi&quot; at the end of the scope
</span></code></pre>
<p><code>"Hi"</code> can only have one owner: initially, this is <code>x</code>. When we write <code>let y = x</code>, we’re moving the ownership of <code>"Hi"</code> from <code>x</code> to <code>y</code>. That is to say, <code>x</code> no longer owns <code>"Hi"</code>. Trying to print <code>x</code> later is an error at compile time, because <code>"Hi"</code> has been <em>moved out of</em> <code>x</code>.</p>
<p>If we want both <code>x</code> and <code>y</code> to hold the string <code>"Hi"</code>, we could make a copy:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string; </span><span style="color:#888888;">// x owns &quot;Hi&quot;
</span><span style="color:#8fbfdc;">let</span><span> y = x.clone();      </span><span style="color:#888888;">// y owns a new copy of &quot;Hi&quot;
</span><span style="color:#888888;">// x drops its &quot;Hi&quot; at the end of the scope
</span><span style="color:#888888;">// y drops its &quot;Hi&quot; at the end of the scope
</span></code></pre>
<p>As its name suggests, <code>.clone()</code> makes a copy of some data. In the above snippet, we end up with not one heap-allocated string, but two! Although this satisfies the ownership model (each <code>"Hi"</code> has exactly one owner), it’s not exactly the most efficient use of space.</p>
<h2 id="aliasable-xor-mutable">Aliasable XOR Mutable</h2>
<p>So far, we’ve been dealing with completely owned data, so let’s talk about borrowing. Rust ensures that all data is <em>Aliasable XOR Mutable</em> (AXM). This essentially means that:</p>
<ol>
<li>All data has exactly one owner.</li>
<li>Data may have many <em>immutable</em> borrows.</li>
<li>Data may have only one <em>mutable</em> borrow at any given point in time.</li>
<li>Data must not be borrowed mutably and immutably at the same time.</li>
</ol>
<p>Let’s make this abstract notion a bit more concrete:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string();    </span><span style="color:#888888;">// x owns &quot;Hi&quot;
</span><span style="color:#8fbfdc;">let</span><span> y = &amp;x;                  </span><span style="color:#888888;">// &#39;&amp;x&#39; immutable borrow of x held by y
</span><span style="color:#8fbfdc;">let</span><span> z = &amp;x;                  </span><span style="color:#888888;">// another immutable borrow of x held by z
</span><span>println!(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}{}{}</span><span style="color:#556633;">&quot;</span><span>, x, y, z); </span><span style="color:#888888;">// prints &quot;HiHiHi&quot;
</span><span style="color:#888888;">// y drops borrow to x, &quot;Hi&quot; is not dropped
</span><span style="color:#888888;">// z drops borrow to x, &quot;Hi&quot; is not dropped
</span><span style="color:#888888;">// x drops &quot;Hi&quot; at the end of the scope
</span></code></pre>
<p>In the above example, <code>x</code> is still the owner of <code>"Hi"</code>. We immutably <em>borrow</em> <code>x</code> twice, in <code>y</code> and <code>z</code>. No copies of <code>"Hi"</code> are made, and <code>x</code> is responsible for cleaning up <code>"Hi"</code> at the end of the scope.</p>
<p>What happens if we try to mutate an immutable borrow?</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// x owns &quot;Hi&quot;
</span><span style="color:#8fbfdc;">let</span><span> y = &amp;x;               </span><span style="color:#888888;">// y immutably borrows x
</span><span>*y = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Bye</span><span style="color:#556633;">&quot;</span><span>.to_string();   </span><span style="color:#888888;">// ERROR: can&#39;t mutate immutable borrow!
</span><span style="color:#888888;">// y drops borrow of x, &quot;Hi&quot; is not dropped
</span><span style="color:#888888;">// x drops &quot;Hi&quot; at the end of the scope
</span></code></pre>
<p>The compiler yells at us, of course!</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>error[E0594]: cannot assign to `*y`, which is behind a `&amp;` reference
</span><span> --&gt; src/main.rs:3:1
</span><span>  |
</span><span>2 | let y = &amp;x;
</span><span>  |         -- help: consider changing this to be a mutable reference: `&amp;mut x`
</span><span>3 | *y = &quot;Bye&quot;.to_string();
</span><span>  | ^^ `y` is a `&amp;` reference, so the data it refers to cannot be written
</span></code></pre>
<p>Obviously, one can’t mutate an immutable reference! Heeding the wisdom of the Rust compiler, let’s try converting <code>y</code> to a mutable reference, <code>&amp;mut</code>:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// x owns &quot;Hi&quot;
</span><span style="color:#8fbfdc;">let</span><span> y = &amp;</span><span style="color:#8fbfdc;">mut</span><span> x;           </span><span style="color:#888888;">// y mutably borrows x
</span><span>*y = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Bye</span><span style="color:#556633;">&quot;</span><span>.to_string();   </span><span style="color:#888888;">// mutate &quot;Hi&quot; to &quot;Bye&quot;
</span><span>println!(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, x);        </span><span style="color:#888888;">// prints &quot;Bye&quot;
</span><span style="color:#888888;">// y drops borrow of x, &quot;Bye&quot; is not dropped
</span><span style="color:#888888;">// x drops &quot;Bye&quot; at the end of the scope
</span></code></pre>
<p>And compiling…</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
</span><span> --&gt; src/main.rs:2:9
</span><span>  |
</span><span>1 | let x = &quot;Hi&quot;.to_string();
</span><span>  |     - help: consider changing this to be mutable: `mut x`
</span><span>2 | let y = &amp;mut x;
</span><span>  |         ^^^^^^ cannot borrow as mutable
</span></code></pre>
<p>Of course, <code>x</code> must be mutable to borrow it as mutable!</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let mut</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// x mutably owns &quot;Hi&quot;
</span><span style="color:#8fbfdc;">let</span><span> y = &amp;</span><span style="color:#8fbfdc;">mut</span><span> x;               </span><span style="color:#888888;">// y mutably borrows x
</span><span>*y = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Bye</span><span style="color:#556633;">&quot;</span><span>.to_string();       </span><span style="color:#888888;">// mutate &quot;Hi&quot; to &quot;Bye&quot;
</span><span>println!(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, x);            </span><span style="color:#888888;">// prints &quot;Bye&quot;
</span><span style="color:#888888;">// y drops borrow of x, &quot;Bye&quot; is not dropped
</span><span style="color:#888888;">// x drops &quot;Bye&quot; at the end of the scope
</span></code></pre>
<p>This works! Just note a couple of things:</p>
<ol>
<li><code>y</code> does not need to be declared using <code>let mut y = ...</code> because <code>y</code> itself is not mutable; the reference it holds is.</li>
<li>Additionally, <code>*</code> <em>dereferences</em> <code>y</code> in <code>*y</code>. Dereferencing is kinda like an anti-borrow, and lets us work with the value the reference contains.</li>
</ol>
<blockquote>
<p><strong>Aside:</strong> As a general rule of thumb, you can’t dereference a borrow unless you’re mutating it (like we do above), or the value is small enough to <code>Copy</code>.</p>
</blockquote>
<p>What happens when we try to hold a mutable and immutable reference at the same time?</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let mut</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// x mutably owns &quot;Hi&quot;
</span><span style="color:#8fbfdc;">let</span><span> w = &amp;x;                   </span><span style="color:#888888;">// w immutably borrows x
</span><span style="color:#8fbfdc;">let</span><span> y = &amp;</span><span style="color:#8fbfdc;">mut</span><span> x;               </span><span style="color:#888888;">// y mutably borrows x
</span><span>*y = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Bye</span><span style="color:#556633;">&quot;</span><span>.to_string();       </span><span style="color:#888888;">// mutate &quot;Hi&quot; to &quot;Bye&quot;
</span></code></pre>
<p>You see, because—</p>
<p>Wait…</p>
<p>Huh? This compiles? Why?</p>
<blockquote>
<p>No, seriously, <a rel="noopener nofollow" target="_blank" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8a5a6d68c3d2240398cd8e5d88b427dd">try it yourself</a>!</p>
</blockquote>
<p>Well, Rust tries to end borrows as early as possible. Let’s write out the above again, but with the correct borrow lifetimes:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let mut</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// x mutably owns &quot;Hi&quot;
</span><span style="color:#8fbfdc;">let</span><span> w = &amp;x;                   </span><span style="color:#888888;">// w immutably borrows x
</span><span style="color:#888888;">// w drops borrow of x, &quot;Bye&quot; is not dropped
</span><span style="color:#888888;">// there are no more borrows to x
</span><span>
</span><span style="color:#8fbfdc;">let</span><span> y = &amp;</span><span style="color:#8fbfdc;">mut</span><span> x;         </span><span style="color:#888888;">// y mutably borrows x
</span><span>*y = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Bye</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// mutate &quot;Hi&quot; to &quot;Bye&quot;
</span><span style="color:#888888;">// y drops borrow of x, &quot;Bye&quot; is not dropped
</span><span>
</span><span style="color:#888888;">// x drops &quot;Bye&quot; at the end of the scope
</span></code></pre>
<p>As you can see, the immutable borrow is dropped <em>before</em> the mutable borrow is made, so we’re actually <em>not</em> holding a mutable and immutable reference at the same time.</p>
<p>To write out the scopes and <em>lifetimes</em> more explicitly:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let mut</span><span> x: String = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// x mutably owns &quot;Hi&quot;
</span><span style="color:#ffb964;">&#39;a</span><span>: {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> w: &amp;</span><span style="color:#8fbfdc;">&#39;a </span><span>String = &amp;</span><span style="color:#8fbfdc;">&#39;a</span><span> x; </span><span style="color:#888888;">// w immutably borrows x
</span><span>    </span><span style="color:#888888;">// w drops borrow of x, &quot;Bye&quot; is not dropped
</span><span>}
</span><span style="color:#ffb964;">&#39;b</span><span>: {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> y: &amp;</span><span style="color:#8fbfdc;">&#39;b mut </span><span>String = &amp;</span><span style="color:#8fbfdc;">&#39;b mut</span><span> x; </span><span style="color:#888888;">// y mutably borrows x
</span><span>    *y = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Bye</span><span style="color:#556633;">&quot;</span><span>.to_string();            </span><span style="color:#888888;">// mutate &quot;Hi&quot; to &quot;Bye&quot;
</span><span>    </span><span style="color:#888888;">// y drops borrow of x, &quot;Bye&quot; is not dropped
</span><span>}
</span><span style="color:#888888;">// x drops &quot;Bye&quot; at the end of the scope
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> <code>'a: {</code> and <code>&amp;'b x</code> is <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/nomicon/lifetimes.html">not valid syntax</a>, but it’s commonly used to show the scopes of lifetimes in Rust.</p>
</blockquote>
<p>These scopes do not overlap, so the lifetimes are <em>disjoint</em>.</p>
<p>“Disjoint? … Lifetimes?” I hear you thinking. “What does this have to do with anything?”</p>
<p>When data is borrowed, it is borrowed for a given <em>lifetime</em>. This is how long the borrow ‘lives’, so to speak.</p>
<blockquote>
<p>Lifetimes are usually denoted with a single apostrophe, like so: <code>'a</code>. This notation was loosely <em>borrowed</em> (no pun) from OCaml, which uses <code>'t</code> to denote generic types.</p>
</blockquote>
<p>So in the above example, the first borrow to <code>x</code>, <code>&amp;'a</code>, lasts for the lifetime <code>'a</code>. Likewise, the second borrow, <code>&amp;'b mut</code>, lasts for the lifetime <code>'b'</code>. Because <code>'a</code> and <code>'b</code> do not overlap, they are <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html">disjoint</a>. Order restored!</p>
<p>Borrowing is baked into Rust’s type system. If you mutably borrow a <code>String</code>, you do not <em>just</em> have a mutably borrowed <code>String</code>. You have an <code>&amp;mut String</code>! The types <code>&amp;mut String</code>, <code>&amp;String</code>, and <code>String</code> are all similar, but not the same.</p>
<blockquote>
<p><strong>Aside:</strong> this is further complicated by the fact that a borrowed string is actually an <code>&amp;str</code>, not an <code>&amp;String</code>. This is because <code>str</code> is a type internal to the compiler, like <code>usize</code>, and <code>String</code> is a heap-allocated container for a <code>str</code> that when borrowed produces an <code>&amp;str</code>.</p>
<p>These distinctions are a bit too fine-grained for what we’re <em>currently</em> dealing with, but it’s important to be aware that these distinctions exist.</p>
</blockquote>
<h2 id="subtyping">Subtyping</h2>
<p>As a matter of fact, <code>&amp;'a String</code> and <code>&amp;'b String</code> may actually be different types entirely, because they have different associated lifetimes!</p>
<p>I say ‘may’ here because it’s possible that <code>'a</code> and <code>'b</code> overlap:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string();
</span><span style="color:#ffb964;">&#39;a</span><span>: {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> y = &amp;</span><span style="color:#8fbfdc;">&#39;a</span><span> x;
</span><span>    </span><span style="color:#ffb964;">&#39;b</span><span>: {
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> z = &amp;</span><span style="color:#8fbfdc;">&#39;b</span><span> y;
</span><span>    }
</span><span>}
</span></code></pre>
<p>As you can see, the lifetime <code>'a</code> completely envelops <code>'b</code>. In other words, <code>'a: 'b</code>, meaning <code>'a</code> outlives <code>'b</code>. For this reason, <code>'a</code> is a <em>subtype</em> of <code>'b</code>.</p>
<blockquote>
<p>The bigger region is a subtype of the smaller region.</p>
</blockquote>
<p>Take a second to internalize this.</p>
<blockquote>
<p>This is a large source of confusion, because it seems backwards to many: the bigger region is a subtype of the smaller region.</p>
<p>— <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/nomicon/subtyping.html">The ’Nomicon</a></p>
</blockquote>
<p><code>'a</code> is a subtype of <code>'b</code> because <code>'a</code> is the same region of code, <em>and more</em>.</p>
<blockquote>
<p>No, seriously, take a second to internalize this.</p>
</blockquote>
<p>If you want to learn more, I recommend you read the <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/nomicon/subtyping.html"><em>Subtyping and Variance</em></a> section of the Rustonomicon. If not, we’ll revisit this topic <a href="https://slightknack.dev/blog/rust-cycles/subtyping-and-variance">later</a>.</p>
<blockquote>
<p>An easy way to remember this relationship is that <code>'static</code>, as in <code>&amp;'static str</code>, is the subtype of <em>all</em> lifetimes, because <code>'static</code> outlives all other lifetimes.</p>
</blockquote>
<h2 id="an-xor-conflict">An XOR Conflict!</h2>
<p>There’s a lot to be said about subtyping and variance, and we’ll discuss it in more depth over the coming sections. Anyway, back to our previous example:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let mut</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// x mutably owns &quot;Hi&quot;
</span><span style="color:#8fbfdc;">let</span><span> w = &amp;x;                   </span><span style="color:#888888;">// w immutably borrows x
</span><span style="color:#8fbfdc;">let</span><span> y = &amp;</span><span style="color:#8fbfdc;">mut</span><span> x;               </span><span style="color:#888888;">// y mutably borrows x
</span><span>*y = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Bye</span><span style="color:#556633;">&quot;</span><span>.to_string();       </span><span style="color:#888888;">// mutate &quot;Hi&quot; to &quot;Bye&quot;
</span></code></pre>
<p>That compiles. This, however, does not:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let mut</span><span> x = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string(); </span><span style="color:#888888;">// x mutably owns &quot;Hi&quot;
</span><span style="color:#8fbfdc;">let</span><span> w = &amp;x;                   </span><span style="color:#888888;">// w immutably borrows x
</span><span style="color:#8fbfdc;">let</span><span> y = &amp;</span><span style="color:#8fbfdc;">mut</span><span> x;               </span><span style="color:#888888;">// y mutably borrows x
</span><span>*y = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Bye</span><span style="color:#556633;">&quot;</span><span>.to_string();       </span><span style="color:#888888;">// mutate &quot;Hi&quot; to &quot;Bye&quot;
</span><span>println!(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, w);            </span><span style="color:#888888;">// ERROR: &quot;Hi&quot; is also borrowed as immutable!
</span></code></pre>
<p>Originally, the lifetimes of the borrows for <code>w</code> and <code>y</code> were disjoint:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let</span><span> x = ...;
</span><span>{
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> w = &amp;x;
</span><span>}
</span><span>{
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> y = &amp;</span><span style="color:#8fbfdc;">mut</span><span> x;
</span><span>}
</span></code></pre>
<p>But with the addition of <code>println!("{}", w)</code>, the scope of <code>w</code> is <em>stretched</em>, like a rubber tube, to envelop <code>y</code>’s scope:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let</span><span> x = ...;
</span><span>{
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> w = &amp;x;
</span><span>    {
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> y = &amp;</span><span style="color:#8fbfdc;">mut</span><span> x;
</span><span>        </span><span style="color:#888888;">// ERROR: w is &amp;x, but y is &amp;mut x!
</span><span>    }
</span><span>    println!(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, w);
</span><span>}
</span></code></pre>
<p>This does not uphold Rust’s <em>Aliasable XOR Mutable</em> requirement, because we’re holding an immutable borrow (in <code>w</code>) and a mutable borrow (in <code>y</code>) at the same time!</p>
<h1 id="inductive-datatypes">Inductive Datatypes</h1>
<p>With the basics of borrow checking out of the way, let’s talk data. Rust requires that all data have exactly one owner. When working with inductive datatypes (loosely anything tree-like; e.g. can easily serialize to JSON), this requirement is not much of an issue:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">User </span><span>{
</span><span>    </span><span style="color:#ffb964;">name</span><span>:    String,
</span><span>    </span><span style="color:#ffb964;">email</span><span>:   Email,
</span><span>    </span><span style="color:#ffb964;">pw_hash</span><span>: Hash,
</span><span>}
</span></code></pre>
<p>All of these fields are owned by the struct <code>User</code>. This makes sense: if fields were externally owned, we’d have to include the borrow in the type:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">User</span><span>&lt;</span><span style="color:#8fbfdc;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#888888;">// ...
</span><span>    </span><span style="color:#ffb964;">documents</span><span>: &amp;</span><span style="color:#8fbfdc;">&#39;a</span><span> [Document],
</span><span>}
</span></code></pre>
<p>As discussed earlier, when we borrow, we borrow for a lifetime. So, <code>&amp;'a [Document]</code> has to live for at least as long as <code>'a</code>. When a type is parameterized by a lifetime (e.g. <code>User&lt;'a&gt;</code>), it means that the data <code>User</code> contains depends on the lifetime.</p>
<p>In fact, you can think of <code>&amp;</code> as a bit of a type constructor itself, like <code>Vec</code> or <code>Box</code>. <code>&amp;</code> takes two arguments: a lifetime, like <code>'a</code>, and a type <code>T</code> to borrow over, like a slice of documents <code>[Document]</code>.</p>
<p>If we were to write this out using standard Rust type-constructor notation, <code>&amp;'a T'</code> would probably look like <code>Borrow&lt;'a, T&gt;</code>. A mutable borrow, like <code>&amp;'a mut T</code>, would be something like <code>BorrowMut&lt;'a, T&gt;</code>. Regardless of the notation used, what’s important to remember is that <strong>borrows can be codified as types</strong>.</p>
<p>Tree-like structures are easy to represent because each field in the tree has exactly one owner: the type they are a field of.</p>
<p>Creating arbitrary graph-like cycles is a bit harder, because each node in the graph may have multiple references, yet Rust requires (somehow), that we have only one owner per node, and that borrowing/variance semantics are upheld.</p>
<p>So let’s throw caution to the wind and write some cycles in Rust:</p>
<h1 id="cyclic-data">Cyclic Data</h1>
<p>It’s can be hard to express cycles in Rust. To illustrate this point, let’s consider this naïve definition of a linked list:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">Link</span><span>&lt;T&gt; {
</span><span>    </span><span style="color:#ffb964;">item</span><span>: T,
</span><span>    </span><span style="color:#ffb964;">prev</span><span>: Option&lt;LinkRef&lt;T&gt;&gt;,
</span><span>    </span><span style="color:#ffb964;">next</span><span>: Option&lt;LinkRef&lt;T&gt;&gt;,
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">type </span><span style="color:#ffb964;">LinkRef</span><span>&lt;T&gt; = Box&lt;Link&lt;T&gt;&gt;;
</span></code></pre>
<p>A <code>Box&lt;T&gt;</code> is an owned pointer to an item of type <code>T</code>. This definition compiles, but if we try to use it in practice, we quickly run into some errors:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#888888;">// trying to make a two-item linked list
</span><span style="color:#888888;">// initialize the first link
</span><span style="color:#8fbfdc;">let mut</span><span> link_1 = Link {
</span><span>    item: </span><span style="color:#cf6a4c;">1</span><span>,
</span><span>    prev: None,
</span><span>    next: None,
</span><span>};
</span><span>
</span><span style="color:#888888;">// initialize the second link with an owned reference to the first
</span><span style="color:#8fbfdc;">let</span><span> link_2 = Link {
</span><span>    item: </span><span style="color:#cf6a4c;">2</span><span>,
</span><span>    prev: Some(Box::new(link_1)),
</span><span>    next: None,
</span><span>};
</span><span>
</span><span style="color:#888888;">// have the first link point to the second
</span><span style="color:#888888;">// ERROR: link_1 has already been moved into link_2!
</span><span>link_1.next = Some(Box::new(link_2))
</span></code></pre>
<p>The issue here is that the first link wants to own the second link, but the second link wants to own the first.</p>
<blockquote>
<p><strong>Note:</strong> With some careful finagling and a pinch of <code>std::mem</code> for good measure, you might be able to set this up without the compiler complaining (as the first node owns the second and the second owns the first, both have one owner). This is no longer the case when we move to larger lists:</p>
</blockquote>
<p>Needless to say, when you get to lists with at least three items, the middle link wants to be owned by two links: the link before it and the link after it. As this requires a single item to have two owners, this won’t fly with Rust’s borrow checker.</p>
<p>Perhaps there’s some way we could change the definition of <code>Link</code>/<code>LinkRef</code> to appease the borrow checker?</p>
<h2 id="workarounds">Workarounds</h2>
<p>Cycles are important components for a large number of datastructures, so it’s no surprise that many techniques for creating cycles in Rust have been developed over the years.</p>
<p>When writing datatypes with circular references, we generally have three choices to appease the borrow checker:</p>
<ol>
<li>Use <code>unsafe</code> and verify correctness ourselves.</li>
<li>Use another level of indirection (e.g. arena, <code>Vec</code> &amp; handle).</li>
<li>Use interior mutability (<code>Rc</code>, <code>Weak</code>, <code>RefCell</code>).</li>
<li>GhostCell!</li>
</ol>
<p>Each of these above methods has its pros and cons; let’s go through each one.</p>
<h3 id="unsafe">Unsafe</h3>
<p>While fast, <code>unsafe</code> is, well, unsafe. It’s easy to mess up the implementation of cyclic data structures. Using <code>unsafe</code>, there’s nothing to ensure that your implementation is correct.</p>
<p>I won’t go into <code>unsafe</code> now, as there will be plenty of <code>unsafe</code> later, but if you want a guide to writing safe linked lists and other similar datastructures in unsafe Rust, check out <a rel="noopener nofollow" target="_blank" href="https://rust-unofficial.github.io/too-many-lists/"><em>Too Many Lists</em></a>.</p>
<h3 id="another-level-of-indirection">Another level of indirection</h3>
<p>Using another level of indirection, like a typed arena, is probably the most common battle-tested technique nowadays. The traditional method of a <code>Vec&lt;T&gt;</code> with a typed index handle is pretty self-explanatory:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#888888;">// a typed region of memory that we manage
</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">LinkArena</span><span>&lt;</span><span style="color:#8fbfdc;">&#39;a</span><span>, T: </span><span style="color:#8fbfdc;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#ffb964;">links</span><span>: Vec&lt;Link&lt;T&gt;&gt;,
</span><span>}
</span><span>
</span><span style="color:#888888;">// an index into that arena
</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">LinkHandle </span><span>{
</span><span>    </span><span style="color:#ffb964;">index</span><span>: </span><span style="color:#8fbfdc;">usize</span><span>,
</span><span>}
</span><span>
</span><span style="color:#888888;">// the link from earlier
</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">Link</span><span>&lt;T&gt; {
</span><span>    </span><span style="color:#ffb964;">item</span><span>: T,
</span><span>    </span><span style="color:#ffb964;">prev</span><span>: Option&lt;LinkRef&lt;T&gt;&gt;,
</span><span>    </span><span style="color:#ffb964;">next</span><span>: Option&lt;LinkRef&lt;T&gt;&gt;,
</span><span>}
</span><span>
</span><span style="color:#888888;">// use a link handle instead of a `Box&lt;LinkRef&lt;T&gt;&gt;`
</span><span style="color:#8fbfdc;">type </span><span style="color:#ffb964;">LinkRef</span><span>&lt;T&gt; = LinkHandle;
</span></code></pre>
<p>The <code>LinkArena</code> maintains single-ownership over all data in the arena. To mutate some data in the arena, you need both a <code>LinkHandle</code> (which is an index into the arena), and a mutable reference to the arena itself. Because <code>LinkHandle</code>s are just indices, we can easily include them in our <code>Link</code>.</p>
<p>Although simple, with this technique we lose a number of guarantees:</p>
<ol>
<li>
<p><strong>We have to pass the arena around whenever we want to follow a handle.</strong> In addition, the <code>prev</code>ious and <code>next</code> items are no longer just convenient fields on the struct. This could be fixed through the use of reference-counting the arena in the handle, or an <code>'arena</code> lifetime. We’ll build things on top of these ideas later.</p>
</li>
<li>
<p><strong>The arena holds items for longer than they may need to be held.</strong> If we remove an item, it won’t be dropped until the arena is dropped. We either have to live with this or implement garbage collection ourselves, which kinda defeats the point of a language whose whole deal is that it doesn’t need to be garbage collected.</p>
</li>
<li>
<p><strong>The amortized cost is higher, because we’re using a <code>Vec</code> as a backing store.</strong> This requires reallocation as it grows in size, whereas just using the native heap will probably be faster. Better arenas use better backing stores (<code>typed-arena</code>, for instance, essentially uses a <code>(Vec&lt;T&gt;, Vec&lt;Vec&lt;T&gt;&gt;)</code> which it carefully manages).</p>
</li>
</ol>
<p>All of these issues can be used by using better arenas than the above implementation. A number of crates, like <a rel="noopener nofollow" target="_blank" href="https://docs.rs/bumpalo/3.8.0/bumpalo/"><code>bumpalo</code></a>, <a rel="noopener nofollow" target="_blank" href="https://docs.rs/petgraph/0.6.0/petgraph/"><code>petgraph</code></a>, <a rel="noopener nofollow" target="_blank" href="https://docs.rs/slotmap/1.0.6/slotmap/"><code>slotmap</code></a>, <a rel="noopener nofollow" target="_blank" href="https://docs.rs/typed-arena/2.0.1/typed_arena/"><code>typed-arena</code></a>,</p>
<p>The most glaring issue is probably summed up by the following quote:</p>
<blockquote>
<p>“All problems in computer science can be solved by another level of indirection, except for the problem of too many levels of indirection”.</p>
<p>— David Wheeler</p>
</blockquote>
<p>Adding an arena is another level of indirection for memory management. Think about it this way: If we allocated <em>everything</em> in an untyped arena, our program would <code>unsafe</code> by any other name.</p>
<h3 id="shared-references-and-interior-mutability">Shared References and Interior Mutability</h3>
<p>In the previous two examples, we’ve been struggling with the constraint of single ownership enforced by the Rust compiler at compile time. If data could just have multiple mutable owners, wouldn’t the whole shebang of constructing cyclical datastructures be a non-issue?</p>
<p>Well yes, but actually no. I’ll explain:</p>
<p>You see, in a single-threaded context, multiple mutable owners are perfectly acceptable, as only one write to the shared data can occur at a time. In contexts with <em>multiple</em> writers, however, this is no longer the case. In multithreaded contexts we run into the issue of <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Race_condition#See_also">race conditions</a> and <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">TOC/TOU</a>: both arise when different threads try write/read data in an uncoordinated manner. This leads to corrupted application state (at best) and segmentation faults (at worst). These types of unpredictable blow-ups are <em>exactly</em> the class of bugs Safe Rust is trying to prevent!</p>
<p>Luckily for us, Rust provides a built-in escape hatch for multiple <em>ownership</em> of shared data: the reference counter pointer <code>Rc</code>, and its multithreaded brother, the atomic reference counter <code>Arc</code>. In short, <code>Rc</code> and <code>Arc</code> keep track of the number of owners some data has. When the reference count reaches zero and there are no owners left, the data is dropped. Because of this, both of these reference types incur a small runtime cost in comparison to raw references.</p>
<blockquote>
<p><strong>Aside:</strong> Reference counting usually incurs <strong>less</strong> of a cost in Rust than in other languages. Why? Because Rust’s borrow checker is so darn smart, in many situations one can usually get away with passing around a <em>reference</em> to a <code>Rc</code>’d pointer—i.e. <code>&amp;Rc&lt;T&gt;</code>—rather than increasing the reference count with each call.</p>
</blockquote>
<p><code>Arc</code> and <code>Rc</code> are only half of the story: these two managed pointers are <em>immutable</em>. When data types are immutable, it’s impossible to build anything that isn’t <a href="https://slightknack.dev/blog/rust-cycles/#inductive-datatypes">inductive</a>: no cyclical references allowed. We need some way to inject mutability into our multiple-owner shared immutable references.</p>
<blockquote>
<p>TODO: RefCell and RwLock</p>
</blockquote>
<h2 id="subtyping-and-variance">Subtyping and Variance</h2>
<blockquote>
<p><strong>Note 1:</strong> This section is quite involved, and only tangentially relates to <code>GhostCell</code>. The key takeaway is that an <strong>invariant lifetime can not change to another lifetime</strong> through subtyping.</p>
</blockquote>
<blockquote>
<p><strong>Note 2:</strong> This section is based on the similarly-titled section of the <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/nomicon/intro.html">Rustonomicon</a>. Check it out!</p>
</blockquote>
<p>Something important to think about is the relationship between type constructors (e.g. <code>Vec</code>) and the lifetimes of the type arguments passed to them (e.g. the <code>T</code> in <code>Vec&lt;T&gt;</code>).</p>
<p>The property of this relationship is called <em>Variance</em>, for better or worse, and it’s important we at least understand <em>invariant</em> lifetimes before we continue.</p>
<p>This table, from the every-handy <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/nomicon/subtyping.html">’Nomicon</a>, shows the variance of lifetime types in Rust:</p>
<table><thead><tr><th>Type Constructor</th><th style="text-align: center"><code>'a</code></th><th style="text-align: center"><code>T</code></th><th style="text-align: center"><code>U</code></th></tr></thead><tbody>
<tr><td><code>&amp;'a T </code></td><td style="text-align: center">covariant</td><td style="text-align: center">covariant</td><td style="text-align: center"></td></tr>
<tr><td><code>&amp;'a mut T</code></td><td style="text-align: center">covariant</td><td style="text-align: center">invariant</td><td style="text-align: center"></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td style="text-align: center"></td><td style="text-align: center">covariant</td><td style="text-align: center"></td></tr>
<tr><td><code>Cell&lt;T&gt;</code></td><td style="text-align: center"></td><td style="text-align: center">invariant</td><td style="text-align: center"></td></tr>
<tr><td><code>fn(T) -&gt; U</code></td><td style="text-align: center"></td><td style="text-align: center">contravariant</td><td style="text-align: center">covariant</td></tr>
<tr><td><code>*const T</code></td><td style="text-align: center"></td><td style="text-align: center">covariant</td><td style="text-align: center"></td></tr>
<tr><td><code>*mut T</code></td><td style="text-align: center"></td><td style="text-align: center">invariant</td><td style="text-align: center"></td></tr>
</tbody></table>
<p>There are three types of variance in Rust. Given a type constructor <code>F</code>, subtype <code>Sub</code>, and a supertype <code>Super</code> (so <code>Sub: Super</code>), variance tells us how the subtyping relationship passes through the type constructor. The variance of <code>F</code> is:</p>
<ol>
<li><strong>Covariant</strong> if subtyping passes through the type constructor. In other words, <code>Sub: Super</code> and <code>F&lt;Sub&gt;: F&lt;Super&gt;</code>.</li>
<li><strong>Contravariant</strong> if subtyping is reversed: if <code>Sub: Super</code>, then <code>F&lt;Super&gt;: F&lt;Sub&gt;</code>. Notice the reversal!</li>
<li><strong>Invariant</strong> if subtyping is not preserved. If <code>Sub: Super</code>, then <code>F&lt;Sub&gt;</code> is disjoint from <code>F&lt;Super&gt;</code>. No relationship exists.</li>
</ol>
<p><code>GhostCell</code>/<code>Token</code> uses an <em>invariant</em> lifetime to ensure that the lifetime remains unique. To see how lifetimes can be used in the place of others, let’s talk about <em>covariance</em>:</p>
<h3 id="covariance">Covariance</h3>
<p>Let’s say we have a function that prints a borrowed <code>String</code>:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">print_string</span><span>&lt;</span><span style="color:#8fbfdc;">&#39;b</span><span>&gt;(</span><span style="color:#ffb964;">string</span><span>: &amp;</span><span style="color:#8fbfdc;">&#39;b</span><span> String) {
</span><span>    println!(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, string);
</span><span>}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> Again, using <code>&amp;String</code> rather than <code>&amp;str</code> for consistency.</p>
</blockquote>
<p>In this function, the argument we borrow from must live at least as long as <code>'b</code>:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">let</span><span> x: String = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hello</span><span style="color:#556633;">&quot;</span><span>.to_string();
</span><span style="color:#ffb964;">&#39;a</span><span>: {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> y: &amp;</span><span style="color:#8fbfdc;">&#39;a </span><span>String = &amp;</span><span style="color:#8fbfdc;">&#39;a</span><span> x;
</span><span>    </span><span style="color:#ffb964;">&#39;b</span><span>: {
</span><span>        print_string::&lt;</span><span style="color:#8fbfdc;">&#39;b</span><span>&gt;(y);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Here we pass <code>y</code> to <code>print_string</code>, which lives for <code>'a</code>. Because <code>'a</code> contains <code>'b</code>, it is perfectly valid to pass a <code>&amp;'a String</code> to <code>print_string&lt;'b&gt;(...)</code>.</p>
<p>We know that <code>'a</code> is a subtype of <code>'b</code>, because, as discussed in the previous section, <code>'a</code> contains the lifetime <code>'b</code> and more. Additionally, we know that <code>&amp;'a String</code> is a subtype of <code>&amp;'b String</code>, because we can use <code>&amp;'a String</code> where we expect <code>&amp;'b String</code>. In this sense, subtyping <em>passes through</em> immutable borrows. Returning to the definition of covariance:</p>
<blockquote>
<p><code>F</code> is covariant if subtyping <em>passes through</em> the type constructor. In other words, <code>Sub: Super</code> and <code>F&lt;Sub&gt;: F&lt;Super&gt;</code>.</p>
</blockquote>
<p>Looking at the example with lifetimes, <code>'a: 'b</code> and <code>&amp;'a T: &amp;'b T</code>. Therefore, we can say that immutably borrowing a value is <em>covariant</em>.</p>
<p>This is the most common type of variance by far:</p>
<table><thead><tr><th>Covariant Type</th><th>Over?</th></tr></thead><tbody>
<tr><td><code>&amp;'a T </code></td><td>Covariant over both <code>'a</code> and <code>T</code>.</td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td>Any collection type (e.g. <code>Vec&lt;T&gt;</code>), is usually covariant over <code>T</code>.</td></tr>
<tr><td><code>*const T</code></td><td>Constant pointer is covariant over <code>T</code>.</td></tr>
</tbody></table>
<p>So if subtyping is preserved for covariant lifetimes, what does it mean when subtyping is <em>not</em> preserved?</p>
<h3 id="invariance">Invariance</h3>
<p>I hope I haven’t lost you. Sometimes I get sucked into abstraction spirals; whenever I do, it’s good to relax and get concrete for a second.</p>
<p>Still with me? Alright.</p>
<p>Let’s talk invariance! Say we have a function that mutates a <code>&amp;mut T</code>:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">mutate</span><span>&lt;</span><span style="color:#8fbfdc;">&#39;a</span><span>, T&gt;(</span><span style="color:#ffb964;">data</span><span>: &amp;</span><span style="color:#8fbfdc;">&#39;a mut</span><span> T, </span><span style="color:#ffb964;">val</span><span>: T) {
</span><span>    *data = val;
</span><span>}
</span></code></pre>
<p>Now consider the following:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffb964;">&#39;static</span><span>: {
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> x: &amp;</span><span style="color:#8fbfdc;">&#39;static </span><span>String = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>; </span><span style="color:#888888;">// Lives for the &#39;static lifeitme
</span><span>    </span><span style="color:#ffb964;">&#39;a</span><span>: {
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> y = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Bye</span><span style="color:#556633;">&quot;</span><span>.to_string();
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> y_borrow: &amp;</span><span style="color:#8fbfdc;">&#39;a </span><span>String = &amp;</span><span style="color:#8fbfdc;">&#39;a</span><span> y; </span><span style="color:#888888;">// Lives only for &#39;a
</span><span>        mutate(&amp;</span><span style="color:#8fbfdc;">mut</span><span> x, y_borrow);         </span><span style="color:#888888;">// Replaces &quot;Hi&quot; with &quot;Bye&quot; in x
</span><span>        </span><span style="color:#888888;">// y drops &quot;Bye&quot; at the end of the scope
</span><span>    }
</span><span>    println!(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, x); </span><span style="color:#888888;">// ERROR: &quot;Bye&quot; has been dropped!
</span><span>}
</span></code></pre>
<p>At first glance, we replace <code>x</code>, which is <code>"Hi"</code> with a value borrowed from <code>y</code>, which is <code>"Bye"</code>. Then, when <code>y</code> exits the scope, <code>"Bye"</code> is dropped. When we later try to print <code>x</code>, aren’t we using memory after we dropped it?</p>
<p>Note that the above is still Aliasable XOR Mutable (AXM): we only have one mutable borrow of <code>x</code>, and one immutable borrow of <code>y</code>. Conceptually, it makes sense that this shouldn’t compile. But if AXM doesn’t explain this, what does?</p>
<p>Let’s write out the types passed to <code>mutate(data: &amp;mut T, val: T)</code>:</p>
<table><thead><tr><th>Arg</th><th>Param</th><th>Generic</th><th>Arg Type</th></tr></thead><tbody>
<tr><td><code>&amp;mut x</code></td><td><code>data</code></td><td><code>&amp;mut T</code></td><td><code>&amp;mut &amp;String</code></td></tr>
<tr><td><code>y_borrow</code></td><td><code>val</code></td><td><code>T</code></td><td><code>&amp;String</code></td></tr>
</tbody></table>
<p>So, from the above table, <code>T</code> must be an <code>&amp;String</code>. So this typechecks, right? Wrong!</p>
<details>
<summary> Expand the big ol' error message.</summary>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>error[E0597]: `y` does not live long enough
</span><span>  --&gt; src/main.rs:5:31
</span><span>   |
</span><span>2  | let mut x: &amp;&#39;static String = &quot;Hi&quot;;
</span><span>   |            --------------- type annotation requires that `y` is borrowed for `&#39;static`
</span><span>...
</span><span>5  |     let y_borrow: &amp;&#39;a String = &amp;&#39;a y;
</span><span>   |                                ^^^^^ borrowed value does not live long enough
</span><span>6  |     mutate(&amp;mut x, y_borrow);
</span><span>...
</span><span>8  | }
</span><span>   | - `y` dropped here while still borrowed
</span></code></pre>
</details>
<p>You see, <code>x</code> and <code>y_borrow</code> are not the same <code>&amp;String</code>. Remember, that the lifetime is a part of the type:</p>
<ul>
<li>So <code>x</code> is a <code>&amp;'static String</code>, borrowed for <code>&amp;'static</code>.</li>
<li>And <code>y_borrow</code> is a <code>&amp;'a String</code>, borrowed for <code>&amp;'a</code>.</li>
</ul>
<p>But remember, <code>'static</code> contains <code>'a</code>, so <code>'static</code> must be a subtype of <code>'a</code>. If <code>'static</code> is a subtype of <code>'a</code>, shouldn’t <code>&amp;mut &amp;'static</code> be a subtype of <code>&amp;mut &amp;'a</code>?</p>
<p>Here’s the clincher:</p>
<blockquote>
<p>Mutable borrows (<code>&amp;mut T</code>) are invariant.</p>
</blockquote>
<p>Returning to the definition of invariance:</p>
<blockquote>
<p><code>F</code> is invariant if subtyping is not preserved.</p>
</blockquote>
<p>Even though <code>'static</code> is a subtype of <code>'a</code>, <code>&amp;mut &amp;'static</code> is <em>not</em> a subtype of <code>&amp;mut &amp;'a</code>. Subtyping <em>does not</em> pass through mutable borrows. For this reason, we can say that immutably borrowing a value is <em>invariant</em> over the lifetime involved.</p>
<p>So mutable and immutable borrows are two ends on opposite sides of the spectrum: immutable borrows can be covariant because even if lifetimes do not match exactly, the underlying lifetime of the value cannot be shortened because the value is immutable. This is not the case for mutable types, so mutable types must be invariant.</p>
<p>Any type that exhibits a pattern of this sort of <em>interior mutability</em> must be invariant, for the reason outlined above. Here are the core invariant types, pay special attention to the last one:</p>
<table><thead><tr><th>Invariant Type</th><th>Over?</th></tr></thead><tbody>
<tr><td><code>&amp;'a mut T</code></td><td>Is invariant over <code>'a</code> and covariant over <code>T</code>.</td></tr>
<tr><td><code>Cell&lt;T&gt;</code></td><td>Interior mutability types (e.g. <code>RefCell</code>, <code>UnsafeCell</code>, atomics, etc.) are all invariant over <code>T</code>.</td></tr>
<tr><td><code>*mut T</code></td><td>Mutable pointers are invariant over <code>T</code>.</td></tr>
</tbody></table>
<p>Invariant types essentially ensure that a given lifetime can not be changed into other lifetimes. This is really important when mutating data, because we want the mutated data to live exactly as long as the data it is replacing.</p>
<h1 id="the-end-for-now">The end… for now!</h1>
<p>Holy moly, how’s that for an exposition!? Stick around for Part II, where we put these principles into practice and derive an implementation of GhostCell from scratch!</p>
<div class="boxed">
<p>This was a longer post than usual, thanks for sticking it out to the end! Huge thanks to my incredible <a rel="noopener nofollow" target="_blank" href="https://www.patreon.com/slightknack">Patrons</a> for making writing this piece possible! I’m also deeply grateful to <a rel="noopener nofollow" target="_blank" href="https://github.com/mkhan45">Mikail</a> and <a rel="noopener nofollow" target="_blank" href="https://github.com/realnegate">Yasser</a> for reviewing (and correcting!) earlier versions of this post.</p>
</div>

<!-- </div> -->

        </div>
        <div class="narrow-unpadded">
            <p class="tag" style="text-wrap: balance;">
                Padded so you can keep scrolling. I know. I love you.
                How about we take you <a href="#top">back up to the top of this page</a>?
            </p>
        </div>
    </div>
<!-- </div> -->

    </body>
</html>
