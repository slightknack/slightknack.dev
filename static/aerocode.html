<!--
  name: AeroCode
  description: CodePen with Frutiger Aero aesthetic
  author: Isaac Clayton (https://isaac.sh)
  tools: Zed, Gemini 3 Pro Preview, Claude Opus 4.5
  repo: https://github.com/slightknack/aerocode
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AeroCode</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/hint/show-hint.min.css">
    <style>
        :root {
            /* =====================================================
               COLOR MODEL - Comprehensive Aqua/Aero System

               THEORY:
               1. BASE PALETTE: 12 core colors from Apollo/PICO-8
               2. ALPHA SCALE: Quantized to 6 steps (10/25/50/75/90/95)
               3. SEMANTIC TOKENS: All derived from base + alpha
               4. NO INLINE COLORS: Everything references variables

               Perceptual notes:
               - Traffic lights use LCH-balanced colors for equal brightness
               - Blues are the primary accent (Aqua heritage)
               - Warm tones (peach/teal) for background gradient
               ===================================================== */

            /* --- Base Palette (12 colors) --- */
            --c-white: #ffffff;
            --c-offwhite: #f5f5f5;
            --c-silver: #c7cfcc;
            --c-gray: #819796;
            --c-gray-warm: #577277;
            --c-dark: #172038;
            --c-navy: #253a5e;

            --c-blue: #4f8fba;
            --c-blue-light: #73bed3;
            --c-blue-dark: #3c5e8b;
            --c-blue-bright: #29adff;

            --c-green: #00d74e;
            --c-green-light: #0ced6a;
            --c-green-dark: #008f17;

            --c-amber: #ffbd2c;
            --c-amber-light: #ffcf45;
            --c-amber-dark: #d37800;

            --c-red: #ff5a5b;
            --c-red-light: #ff8680;
            --c-red-dark: #c62a34;

            --c-peach: #fed6e3;
            --c-teal: #a8edea;

            /* --- Alpha Scale (quantized to 6 steps) --- */
            --alpha-white-95: rgba(255, 255, 255, 0.95);
            --alpha-white-90: rgba(255, 255, 255, 0.9);
            --alpha-white-75: rgba(255, 255, 255, 0.75);
            --alpha-white-50: rgba(255, 255, 255, 0.5);
            --alpha-white-25: rgba(255, 255, 255, 0.25);
            --alpha-white-10: rgba(255, 255, 255, 0.1);

            --alpha-black-50: rgba(0, 0, 0, 0.5);
            --alpha-black-25: rgba(0, 0, 0, 0.25);
            --alpha-black-10: rgba(0, 0, 0, 0.1);
            --alpha-black-05: rgba(0, 0, 0, 0.05);

            /* Colored alphas (for highlights) */
            --alpha-blue-10: rgba(79, 143, 186, 0.1);
            --alpha-red-10: rgba(255, 90, 91, 0.1);

            /* --- Derived: Button grays (from white with black overlay) --- */
            --c-btn-light: #e8e8e8;
            --c-btn-mid: #e0e0e0;
            --c-btn-dark: #d8d8d8;

            /* =====================================================
               SEMANTIC TOKENS - Composed from palette
               ===================================================== */

            /* --- Text --- */
            --text: var(--c-dark);
            --text-muted: var(--c-gray-warm);
            --text-faint: var(--c-gray);
            --text-inverse: var(--c-white);

            /* --- Backgrounds --- */
            --bg-body-grad-1: var(--c-teal);
            --bg-body-grad-2: var(--c-peach);
            --bg-glass: var(--alpha-white-75);
            --bg-content: var(--alpha-white-50);
            --bg-header: linear-gradient(to bottom, var(--c-white) 0%, var(--c-offwhite) 100%);
            --bg-gutter: var(--alpha-white-95);
            --bg-sidebar: linear-gradient(to bottom, var(--alpha-white-50) 0%, var(--alpha-white-25) 100%);

            /* --- Borders --- */
            --border-light: var(--alpha-white-90);
            --border-dark: var(--alpha-black-10);
            --border-btn: var(--alpha-black-10);

            /* --- Accent (interactive) --- */
            --accent: var(--c-blue);
            --accent-hover: var(--c-blue-dark);
            --accent-border: var(--c-navy);

            /* =====================================================
               COMPONENT TOKENS
               ===================================================== */

            /* --- Shadows (using quantized alpha) --- */
            --shadow-drop-sm: 0 1px 2px var(--alpha-black-10);
            --shadow-drop-md: 0 2px 4px var(--alpha-black-10);
            --shadow-drop-lg: 0 3px 6px var(--alpha-black-25);
            --shadow-inset-highlight: 0 1px 0 var(--alpha-white-90) inset;
            --shadow-inset-highlight-bright: 0 1px 0 var(--c-white) inset;
            --shadow-inset-depth: 0 -1px 2px var(--alpha-black-10) inset;
            --shadow-inset-pressed: 0 2px 3px var(--alpha-black-25) inset;
            --shadow-panel: 0 2px 8px var(--alpha-black-05), 0 1px 2px var(--alpha-black-05);
            --shadow-subtle: 0 4px 10px var(--alpha-black-05);

            /* --- Button Gradients --- */
            --gradient-button: linear-gradient(to bottom, var(--c-white) 0%, var(--c-btn-mid) 100%);
            --gradient-button-hover: linear-gradient(to bottom, var(--c-white) 0%, var(--c-btn-light) 100%);
            --gradient-button-pressed: linear-gradient(to bottom, var(--c-btn-dark) 0%, var(--c-btn-light) 100%);
            --gradient-accent: linear-gradient(to bottom, var(--c-blue) 0%, var(--c-blue-dark) 100%);
            --gradient-accent-hover: linear-gradient(to bottom, var(--c-blue-light) 0%, var(--c-blue) 100%);
            --gradient-shine: linear-gradient(to bottom, var(--alpha-white-75), transparent);
            --gradient-shine-pressed: linear-gradient(to top, var(--alpha-white-25), transparent);

            /* --- Traffic Lights (perceptually balanced) --- */
            --traffic-red: linear-gradient(to bottom, var(--c-red-light) 0%, var(--c-red) 100%);
            --traffic-red-border: var(--c-red-dark);
            --traffic-red-pressed: linear-gradient(to bottom, var(--c-red-dark) 0%, var(--c-red) 100%);
            --traffic-amber: linear-gradient(to bottom, var(--c-amber-light) 0%, var(--c-amber) 100%);
            --traffic-amber-border: var(--c-amber-dark);
            --traffic-amber-pressed: linear-gradient(to bottom, var(--c-amber-dark) 0%, var(--c-amber) 100%);
            --traffic-green: linear-gradient(to bottom, var(--c-green-light) 0%, var(--c-green) 100%);
            --traffic-green-border: var(--c-green-dark);
            --traffic-green-pressed: linear-gradient(to bottom, var(--c-green-dark) 0%, var(--c-green) 100%);

            /* --- Share Button (uses blue-bright from palette) --- */
            --c-share-light: #6ac1ff;
            --c-share-dark: #0074c3;
            --gradient-share: linear-gradient(to bottom, var(--c-share-light) 0%, var(--c-blue-bright) 100%);
            --gradient-share-hover: linear-gradient(to bottom, var(--c-blue-light) 0%, var(--c-share-light) 100%);
            --gradient-share-pressed: linear-gradient(to bottom, var(--c-share-dark) 0%, var(--c-blue-bright) 100%);
            --share-border: var(--c-share-dark);

            /* --- Console badges (derived from palette) --- */
            --console-info: var(--c-blue);
            --console-warn: var(--c-amber);
            --console-warn-text: var(--c-amber-dark);
            --console-error: var(--c-red);
            --console-error-text: var(--c-red-dark);

            /* --- Code hints (derived from palette) --- */
            --hint-bg-from: var(--c-blue-light);
            --hint-bg-to: var(--c-blue);

            /* --- Strips (resize handles) --- */
            --strip-bg: var(--c-blue);
            --strip-bg-hover: var(--c-blue-dark);
            --strip-border: var(--c-blue-dark);

            /* =====================================================
               LAYOUT
               ===================================================== */
            --header-height: 32px;
            --gap: 8px;
            --radius: 10px;

            /* =====================================================
               FONTS
               ===================================================== */
            --font-mono: 'Menlo', 'Consolas', monospace;
            --font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
            font-family: var(--font-ui);
            background:
                radial-gradient(circle at 10% 10%, var(--alpha-white-75) 0%, transparent 40%),
                linear-gradient(135deg, var(--bg-body-grad-1) 0%, var(--bg-body-grad-2) 100%);
        }

        .hidden { display: none !important; }

        /* Shared header bar style */
        .header-bar {
            height: var(--header-height);
            min-height: var(--header-height);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            background: var(--bg-header);
            user-select: none;
            flex-shrink: 0;
        }

        /* Shared panel style */
        .panel {
            background: var(--bg-glass);
            border: 1px solid var(--border-light);
            border-radius: var(--radius);
            box-shadow: var(--shadow-panel);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .label {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 0 var(--c-white);
        }

        .controls { display: flex; gap: 6px; align-items: center; position: relative; }

        /* Red exit button overlays green fullscreen button */
        .controls .btn-red[data-action="exit-fullscreen"] {
            position: absolute;
            right: 0;
        }

        /* Utility classes */
        .flex-center { display: flex; align-items: center; }
        .flex-gap { display: flex; gap: 4px; }

        /* Small text button (copy, clear) */
        .text-btn {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            cursor: pointer;
            margin-left: 8px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .text-btn:hover { opacity: 1; color: var(--text); }
        .text-btn.active { color: var(--accent); opacity: 1; }

        /* Pill buttons: --pill-h controls shine inset (h/4) */
        .pill {
            --pill-h: 20px;
            --pill-shine-inset: calc(var(--pill-h) / 4);
            position: relative;
            font-size: 10px;
            font-weight: 600;
            padding: 3px 10px;
            border-radius: 50px;
            cursor: pointer;
            background: var(--gradient-button);
            color: var(--text-muted);
            box-shadow: var(--shadow-drop-md), var(--shadow-inset-highlight), var(--shadow-inset-depth);
            border: 1px solid var(--border-btn);
            transition: transform 0.15s ease-out, box-shadow 0.15s ease-out, background 0.15s ease-out;
            transform: translateY(0);
        }
        .pill::after {
            content: "";
            position: absolute;
            top: 1px;
            left: var(--pill-shine-inset);
            right: var(--pill-shine-inset);
            height: 50%;
            background: var(--gradient-shine);
            border-radius: 50px;
            pointer-events: none;
        }
        .pill:hover {
            transform: translateY(-1px);
            box-shadow:
                var(--shadow-drop-lg),
                var(--shadow-inset-highlight-bright),
                var(--shadow-inset-depth),
                0 1px 0 var(--border-btn);
            background: var(--gradient-button-hover);
        }
        .pill:active {
            transform: translateY(0);
            box-shadow: var(--shadow-drop-sm), var(--shadow-inset-pressed);
            background: var(--gradient-button-pressed);
        }
        .pill:active::after {
            opacity: 0.3;
        }
        .pill.active {
            transform: translateY(0);
            background: var(--gradient-accent);
            color: var(--text-inverse);
            text-shadow: 0 1px 1px var(--alpha-black-25);
            border-color: var(--accent-border);
            box-shadow: 0 1px 0 var(--alpha-white-10), var(--shadow-inset-pressed);
        }
        .pill.active::after {
            top: auto;
            bottom: 1px;
            height: 45%;
            background: var(--gradient-shine-pressed);
        }
        .pill.active:hover {
            background: var(--gradient-accent-hover);
        }

        /* SHARE button - prominent green CTA */
        #share-btn {
            background: var(--gradient-share);
            color: var(--text-inverse);
            border-color: var(--share-border);
            text-shadow: 0 -1px 0 var(--alpha-black-25);
        }
        #share-btn::after {
            background: linear-gradient(to bottom, var(--alpha-white-50), transparent);
        }
        #share-btn:hover {
            background: var(--gradient-share-hover);
        }
        #share-btn:active {
            background: var(--gradient-share-pressed);
        }
        #share-btn.active {
            background: var(--gradient-accent);
            border-color: var(--accent-border);
        }
        #share-btn.active::after {
            display: none;
        }

        /* Frutiger Aero traffic light buttons - no lift, just glow */
        .traffic-btn {
            position: relative;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: box-shadow 0.15s ease-out, filter 0.15s ease-out;
            background: var(--btn-bg);
            border: 1px solid var(--btn-border);
            box-shadow: 0 1px 2px var(--alpha-black-25), 0 1px 0 var(--alpha-white-50) inset, 0 -1px 2px var(--alpha-black-10) inset;
        }
        .traffic-btn::after {
            content: "";
            position: absolute;
            top: 1px;
            left: 15%;
            right: 15%;
            height: 45%;
            background: linear-gradient(to bottom, var(--alpha-white-50), transparent);
            border-radius: 50%;
            pointer-events: none;
            transition: opacity 0.15s ease-out;
        }
        .traffic-btn svg { width: 8px; height: 8px; opacity: 0; }
        .traffic-btn:hover { box-shadow: 0 1px 2px var(--alpha-black-25), 0 1px 0 var(--alpha-white-75) inset, 0 -1px 2px var(--alpha-black-10) inset; filter: brightness(1.1); }
        .traffic-btn:hover svg { opacity: 0.7; }
        .traffic-btn:hover::after { opacity: 0.9; }
        .traffic-btn:active { background: var(--btn-bg-pressed); box-shadow: 0 1px 1px var(--alpha-black-10), var(--shadow-inset-pressed); filter: brightness(0.95); }
        .traffic-btn:active::after { top: auto; bottom: 1px; background: linear-gradient(to top, var(--alpha-white-50), transparent); }
        .traffic-btn path { stroke: var(--alpha-black-50); stroke-width: 1.5; stroke-linecap: round; }
        .btn-yellow { --btn-bg: var(--traffic-amber); --btn-border: var(--traffic-amber-border); --btn-bg-pressed: var(--traffic-amber-pressed); }
        .btn-green { --btn-bg: var(--traffic-green); --btn-border: var(--traffic-green-border); --btn-bg-pressed: var(--traffic-green-pressed); }
        .btn-red { --btn-bg: var(--traffic-red); --btn-border: var(--traffic-red-border); --btn-bg-pressed: var(--traffic-red-pressed); }

        /* Drag overlay */
        #drag-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            display: none;
        }

        /* Sidebar strips */
        .sidebar-strip, .preview-strip {
            width: 16px;
            height: 100vh;
            background: var(--strip-bg);
            cursor: col-resize;
            display: none;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        .sidebar-strip { border-right: 1px solid var(--strip-border); }
        .preview-strip { border-left: 1px solid var(--strip-border); flex-shrink: 0; }
        .sidebar-strip:hover, .preview-strip:hover { background: var(--strip-bg-hover); }

        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            background: var(--bg-sidebar);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid var(--alpha-white-50);
            padding: var(--gap);
            padding-bottom: 0;
            z-index: 10;
            position: relative;
            flex-shrink: 0;
        }

        .sidebar-resizer {
            position: absolute;
            top: 0;
            bottom: 0;
            right: -4px;
            width: 10px;
            cursor: col-resize;
            z-index: 50;
        }

        /* Editor boxes */
        .editor-box {
            position: absolute;
            left: var(--gap);
            right: var(--gap);
        }
        .editor-box .header-bar { border-bottom: 1px solid var(--border-dark); }
        .preview > .header-bar { border-bottom: 1px solid var(--border-dark); }

        .editor-content {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-content);
        }

        /* Fallback textarea styling (when CodeMirror not loaded) */
        .editor-content textarea {
            width: 100%;
            height: 100%;
            border: none;
            padding: 8px 12px;
            margin: 0;
            resize: none;
            background: transparent;
            color: var(--text);
            font: 13px/1.5 var(--font-mono);
            outline: none;
            tab-size: 2;
        }

        /* Plain mode - show textareas */
        .plain-mode .editor-content textarea {
            display: block !important;
        }

        /* Offline mode - hide mode switcher, show OFFLINE label */
        .offline-label { display: none; }
        .offline-mode .mode-switcher { display: none !important; }
        .offline-mode .offline-label { display: inline !important; }

        /* Editor fullscreen mode */
        .sidebar.fullscreen-mode .editor-box { display: none; }
        .sidebar.fullscreen-mode .editor-box.fs-active {
            display: flex;
            position: absolute;
            top: var(--gap) !important;
            bottom: calc(var(--header-height) + var(--gap)) !important;
            height: auto !important;
            z-index: 100;
        }
        .fullscreen-mode .label { display: none; }
        /* Floating fullscreen header */
        .fs-header {
            display: none;
            position: absolute;
            top: var(--gap);
            left: calc(var(--gap) + 8px);
            height: var(--header-height);
            z-index: 200;
            align-items: center;
            gap: 8px;
        }
        .fullscreen-mode .fs-header {
            display: flex;
        }
        body.layout-mobile .fs-header {
            top: 0;
            left: 8px;
        }
        .fs-header .fs-nav {
            display: flex;
        }

        /* Hide individual panel labels and copy buttons in fullscreen */
        .fullscreen-mode .editor-box .label,
        .fullscreen-mode .editor-box .text-btn[data-lang] {
            display: none;
        }

        /* Segmented control wrapper */
        .segmented-control {
            display: flex;
            position: relative;
            background: var(--alpha-black-10);
            border-radius: 9999px;
            padding: 3px;
            gap: 2px;
            box-shadow:
                inset 0 2px 4px var(--alpha-black-10),
                inset 0 1px 2px var(--alpha-black-10),
                0 1px 0 var(--alpha-white-50);
        }
        /* Sliding background */
        .segmented-control::before {
            content: "";
            position: absolute;
            top: 3px;
            bottom: 3px;
            left: calc(3px + var(--active-left, 0px));
            width: var(--active-width, 50px);
            background: linear-gradient(to bottom, var(--c-white) 0%, var(--c-btn-light) 100%);
            border-radius: 9999px;
            box-sizing: border-box;
            box-shadow:
                0 1px 1px var(--alpha-black-10),
                0 1px 0 var(--alpha-white-90) inset;
            transition: var(--slider-transition, left 0.2s ease, width 0.2s ease);
            z-index: 0;
        }

        .segmented-control .pill {
            position: relative;
            z-index: 1;
            padding: 3px 10px;
            background: transparent;
            box-shadow: none;
            border: none;
            transform: none;
            color: var(--text-muted);
            text-shadow: none;
            transition: color 0.2s ease, text-shadow 0.2s ease;
        }
        .segmented-control .pill::after {
            display: none;
        }
        .segmented-control .pill::before {
            content: "";
            position: absolute;
            inset: 0;
            background: var(--alpha-black-10);
            border-radius: 9999px;
            opacity: 0;
            transition: opacity 0.15s ease;
            pointer-events: none;
        }
        .segmented-control .pill:hover {
            transform: none;
            background: transparent;
            box-shadow: none;
            color: var(--text);
        }
        .segmented-control .pill:not(.active):hover::before { opacity: 1; }
        .segmented-control .pill:active, .segmented-control .pill.active, .segmented-control .pill.active:hover { background: transparent; }
        .segmented-control .pill.active { color: var(--text); text-shadow: 0 1px 0 var(--alpha-white-50); box-shadow: none; transition: color 0.2s ease, text-shadow 0.2s ease; }

        /* Bottom toolbar */
        .bottom-toolbar { position: absolute; bottom: 0; left: 0; right: 0; border-top: 1px solid var(--border-dark); z-index: 50; }

        /* Preview area */
        .preview { flex: 1; min-width: 0; background: white; position: relative; overflow: hidden; display: flex; flex-direction: column; }
        .iframe-container { position: relative; flex: 1; min-height: 0; }
        .iframe-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; background: white; }

        /* Console panel */
        .console-panel { border-top: 1px solid var(--border-dark); border-bottom: none; border-left: none; border-right: none; border-radius: 0; box-shadow: none; flex-shrink: 0; }
        .console-panel .header-bar { cursor: row-resize; border-bottom: 1px solid var(--border-dark); }
        .console-panel.collapsed .console-body { display: none; }
        .console-panel.fullscreen { flex: 1 1 auto; border-radius: 0; }
        .preview:has(.console-panel.fullscreen) .iframe-container { display: none; }

        .console-badge { background: var(--c-gray); color: var(--text-inverse); font-family: var(--font-ui); font-size: 9px; font-weight: 600; padding: 2px 6px; border-radius: 10px; min-width: 16px; text-align: center; margin-left: 6px; }
        .console-badge.has-errors { background: var(--console-error); }
        .console-filters { margin-left: 8px; margin-right: 8px; }
        .console-body { flex: 1; overflow-y: auto; font-family: var(--font-mono); font-size: 12px; line-height: 1.4; background: var(--bg-content); }

        .console-entry { padding: 4px 12px; border-bottom: 1px solid var(--alpha-black-05); display: flex; align-items: flex-start; gap: 8px; }
        .console-entry:hover { background: var(--alpha-black-05); }

        .console-time { color: var(--text-faint); font-size: 10px; flex-shrink: 0; margin-top: 3px; }
        .console-type { font-family: var(--font-ui); font-size: 10px; font-weight: 600; padding: 2px 10px; border-radius: 50px; flex-shrink: 0; cursor: pointer; border: 1px solid var(--alpha-black-10); box-sizing: border-box; box-shadow: var(--shadow-inset-highlight), var(--shadow-inset-depth); text-shadow: 0 1px 0 var(--alpha-white-25); }
        .console-type.log { background: var(--gradient-button); color: var(--text-muted); }
        .console-type.info { background: linear-gradient(to bottom, var(--c-blue-light) 0%, var(--c-blue) 100%); color: var(--text-inverse); border-color: var(--c-blue-dark); text-shadow: 0 -1px 0 var(--alpha-black-25); }
        .console-type.warn { background: var(--traffic-amber); color: var(--text-inverse); border-color: var(--traffic-amber-border); text-shadow: 0 -1px 0 var(--alpha-black-25); }
        .console-type.error { background: var(--traffic-red); color: var(--text-inverse); border-color: var(--traffic-red-border); text-shadow: 0 -1px 0 var(--alpha-black-25); }
        .console-type.log.copied { background: var(--gradient-button-pressed); box-shadow: var(--shadow-inset-pressed); }
        .console-type.info.copied { background: linear-gradient(to bottom, var(--c-blue-dark) 0%, var(--c-blue) 100%); box-shadow: var(--shadow-inset-pressed); }
        .console-type.warn.copied { background: var(--traffic-amber-pressed); box-shadow: var(--shadow-inset-pressed); }
        .console-type.error.copied { background: var(--traffic-red-pressed); box-shadow: var(--shadow-inset-pressed); }

        .console-message { color: var(--text); word-break: break-word; flex: 1; white-space: pre-wrap; text-align: left; margin-top: 3px; }
        .console-entry.warn .console-message { color: var(--console-warn-text); }
        .console-entry.error .console-message { color: var(--console-error-text); }

        .console-line { color: var(--accent); cursor: pointer; flex-shrink: 0; font-size: 11px; align-self: center; }
        .console-line:hover { text-decoration: underline; }

        .console-count { background: var(--c-gray); color: var(--text-inverse); font-family: var(--font-ui); font-size: 9px; font-weight: 600; padding: 2px 6px; border-radius: 10px; margin-left: 6px; flex-shrink: 0; }

        .console-empty { color: var(--text-faint); text-align: center; padding: 20px; font-style: italic; }

        /* CodeMirror */
        .CodeMirror {
            position: absolute;
            inset: 0;
            height: 100% !important;
            background: transparent !important;
            font-family: var(--font-mono);
            font-size: 12px;
            line-height: 1.4;
        }
        .CodeMirror-gutters {
            background: var(--bg-gutter) !important;
            border-right: 1px solid var(--border-dark) !important;
        }

        /* Code hints */
        .CodeMirror-hints {
            background: var(--alpha-white-90);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            box-shadow: 0 4px 12px var(--alpha-black-10);
            font-family: var(--font-mono);
            font-size: 12px;
            padding: 4px 0;
            z-index: 1000;
            max-height: 200px;
            overflow-y: auto;
        }
        .CodeMirror-hint { padding: 4px 10px; color: var(--text); cursor: pointer; }
        .CodeMirror-hint-active {
            background: linear-gradient(to bottom, var(--hint-bg-from) 0%, var(--hint-bg-to) 100%);
            color: var(--text-inverse);
            border-radius: 3px;
            margin: 0 4px;
        }

        /* Error highlighting (runtime errors from console) */
        .cm-error-line { background: var(--alpha-red-10) !important; }

        /* Matched tag highlighting */
        .CodeMirror-matchingtag { background: var(--alpha-blue-10); }

        /* ==============================================
           SYNTAX HIGHLIGHTING (unified across languages)
           Using palette colors for consistency
           ============================================== */

        /* Keywords, tags, selectors (structural) */
        .cm-keyword { color: var(--c-blue-dark); font-weight: 600; }
        .cm-tag { color: var(--c-blue-dark); }
        .cm-qualifier { color: var(--c-blue-dark); }
        .cm-builtin { color: var(--c-blue-dark); }

        /* Properties, attributes (descriptive) */
        .cm-attribute { color: var(--c-amber-dark); }
        .cm-property { color: var(--c-amber-dark); }
        .cm-variable { color: var(--c-dark); }
        .cm-variable-2 { color: var(--c-navy); }
        .cm-variable-3 { color: var(--c-blue); }
        .cm-def { color: var(--c-navy); }

        /* Values, strings, numbers (data) */
        .cm-string { color: var(--c-green-dark); }
        .cm-string-2 { color: var(--c-green-dark); }
        .cm-number { color: var(--c-amber); }
        .cm-atom { color: var(--c-amber); }

        /* Comments, meta (secondary) */
        .cm-comment { color: var(--c-gray); font-style: italic; }
        .cm-meta { color: var(--c-gray); }

        /* Punctuation */
        .cm-bracket { color: var(--c-gray-warm); }
        .cm-operator { color: var(--c-gray-warm); }

        /* ==============================================
           CONDITIONAL VISIBILITY SYSTEM
           [data-show="mobile"] - only visible in mobile layout
           [data-show="desktop"] - only visible in desktop layout
           ============================================== */
        /* Default: hide mobile elements, show desktop elements */
        [data-show="mobile"] { display: none !important; }

        /* Mobile layout: show mobile elements, hide desktop elements */
        body.layout-mobile [data-show="mobile"] { display: flex !important; }
        body.layout-mobile [data-show="desktop"] { display: none !important; }

        /* Desktop: text-btn should be inline, not flex */
        .text-btn[data-show="desktop"] { display: inline !important; }

        /* ==============================================
           MOBILE LAYOUT STYLES
           Applied when body has .layout-mobile class
           ============================================== */

        /* Both sidebar and preview are full-screen in mobile */
        body.layout-mobile .sidebar,
        body.layout-mobile .preview {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100% !important;
        }

        /* Mobile view states */
        body.layout-mobile.view-code .sidebar { display: flex; z-index: 10; }
        body.layout-mobile.view-code .preview { display: none; }

        body.layout-mobile.view-preview .sidebar { display: none; }
        body.layout-mobile.view-preview .preview { display: flex; z-index: 10; }
        body.layout-mobile.view-preview .console-panel { display: none; }

        body.layout-mobile.view-console .sidebar { display: none; }
        body.layout-mobile.view-console .preview { display: flex; z-index: 10; }
        body.layout-mobile.view-console .iframe-container { display: none; }
        /* Preview header bar hidden in console view (it uses data-show="mobile" so it's shown,
           but we want it hidden when viewing console) */
        body.layout-mobile.view-console .preview > .header-bar[data-show="mobile"] { display: none !important; }
        body.layout-mobile.view-console .console-panel {
            flex: 1;
            max-height: none;
            border-radius: 0;
            border: none;
        }

        /* Mobile: full bleed layout with no gaps or rounded corners */
        body.layout-mobile .sidebar {
            padding: 0;
            background: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            border: none;
        }
        body.layout-mobile .sidebar .editor-box { display: none; }
        body.layout-mobile .sidebar .editor-box.fs-active {
            display: flex;
            position: absolute;
            top: 0 !important;
            left: 0;
            right: 0;
            bottom: var(--header-height) !important;
            height: auto !important;
            border-radius: 0;
            border: none;
        }
        body.layout-mobile .sidebar .bottom-toolbar {
            border-radius: 0;
        }

        /* Hide red exit-fullscreen button in mobile */
        body.layout-mobile .traffic-btn.btn-red { display: none !important; }

        /* Hide resizers and strips in mobile */
        body.layout-mobile .sidebar-resizer,
        body.layout-mobile .sidebar-strip,
        body.layout-mobile .preview-strip { display: none !important; }

        /* Console adjustments for mobile */
        body.layout-mobile .console-panel {
            max-height: 50vh;
        }

        .console-toolbar {
            border-top: 1px solid var(--border-dark);
            justify-content: space-between;
        }


        /* Larger touch targets for mobile */
        body.layout-mobile {
            --header-height: 52px;
        }
        body.layout-mobile .pill {
            --pill-h: 40px;  /* Mobile: larger touch targets */
            padding: 13px 12px;
            border-radius: 9999px;
        }

        /* Code hints adjustments for small screens */
        @media (max-width: 800px) {
            .CodeMirror-hints {
                max-width: calc(100vw - 20px);
                max-height: 150px;
            }
        }
    </style>
</head>
<body>
    <div id="drag-overlay"></div>
    <div id="sidebar-strip" class="sidebar-strip"></div>

    <div id="sidebar" class="sidebar">
        <div class="sidebar-resizer" id="sidebar-resizer"></div>

        <!-- Floating header for fullscreen mode -->
        <div class="fs-header" id="fs-header">
            <div class="fs-nav segmented-control" id="lang-switcher">
                <span class="pill active" data-panel="html">HTML</span>
                <span class="pill" data-panel="css">CSS</span>
                <span class="pill" data-panel="js">JS</span>
            </div>
            <span class="text-btn" id="fs-copy" data-lang="html">copy</span>
        </div>

        <div class="editor-box panel" id="box-html">
            <div class="header-bar" id="header-html">
                <div class="flex-center">
                    <span class="label" data-show="desktop">HTML</span>
                    <span class="text-btn" data-lang="html">copy</span>
                </div>
                <div class="controls">
                    <span class="pill" data-show="mobile" data-mobile-view="console">CONSOLE</span>
                    <span class="pill" data-show="mobile" data-mobile-view="preview">PREVIEW</span>
                    <div class="traffic-btn btn-yellow" data-show="desktop" data-action="minimize" data-panel="html">
                        <svg viewBox="0 0 10 10"><path d="M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-green" data-show="desktop" data-action="fullscreen" data-panel="html">
                        <svg viewBox="0 0 10 10"><path d="M5,2 L5,8 M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-red" data-action="exit-fullscreen" data-panel="html" style="visibility:hidden">
                        <svg viewBox="0 0 10 10"><path d="M2,2 L8,8 M8,2 L2,8"/></svg>
                    </div>
                </div>
            </div>
            <div class="editor-content"><textarea id="code-html"><div class="card">
  <img src="https://slightknack.dev/content/path.jpg">
  <div class="content">
    <div>
      <h1>AeroCode</h1>
      <p><a href="https://isaac.sh/about" target="_blank">Isaac Clayton</a> Â· <a href="https://github.com/slightknack/aerocode" target="_blank">GitHub</a></p>
    </div>
    <button>Download Offline Editor</button>
  </div>
</div></textarea></div>
        </div>

        <div class="editor-box panel" id="box-css">
            <div class="header-bar" id="header-css">
                <div class="flex-center">
                    <span class="label" data-show="desktop">CSS</span>
                    <span class="text-btn" data-lang="css">copy</span>
                </div>
                <div class="controls">
                    <span class="pill" data-show="mobile" data-mobile-view="console">CONSOLE</span>
                    <span class="pill" data-show="mobile" data-mobile-view="preview">PREVIEW</span>
                    <div class="traffic-btn btn-yellow" data-show="desktop" data-action="minimize" data-panel="css">
                        <svg viewBox="0 0 10 10"><path d="M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-green" data-show="desktop" data-action="fullscreen" data-panel="css">
                        <svg viewBox="0 0 10 10"><path d="M5,2 L5,8 M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-red" data-action="exit-fullscreen" data-panel="css" style="visibility:hidden">
                        <svg viewBox="0 0 10 10"><path d="M2,2 L8,8 M8,2 L2,8"/></svg>
                    </div>
                </div>
            </div>
            <div class="editor-content"><textarea id="code-css">.card {
  max-width: 500px;
  border-radius: 20px;
  overflow: hidden;
  background: #fffb;
  backdrop-filter: blur(20px);
  box-shadow: 0 20px 40px #0002, inset 0 1px 0 #fff;
}

.card img { width: 100%; display: block; }

.content {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  gap: 16px;
}

h1 { margin: 0; font: 700 26px system-ui; color: #172038; }
p { margin: 2px 0 0; font: 14px system-ui; color: #577277; }
a { color: inherit; text-decoration: none; }
a:hover { text-decoration: underline; }

button {
  padding: 12px 24px;
  font: 600 15px system-ui;
  color: #fff;
  border: none;
  border-radius: 100px;
  background: linear-gradient(to bottom, #29adff, #4f8fba);
  border-bottom: 3px solid #3c5e8b;
  box-shadow: 0 4px 12px #29adff55, inset 0 1px 0 #fff6;
  cursor: pointer;
  transition: 0.15s;
}

button:hover { border-bottom-width: 5px; margin-top: -2px; }
button:active { border-bottom-width: 1px; margin-top: 2px; }

/* Page layout */
* { box-sizing: border-box; }
body {
  min-height: 100vh;
  margin: 0;
  padding: 16px;
  display: grid;
  place-items: center;
  background: linear-gradient(135deg, #a8edea, #fed6e3);
}

/* Animated grid background */
body::before {
  content: "";
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(
    0deg, #0001 0 1px, transparent 1px 24px
  ), repeating-linear-gradient(
    90deg, #0001 0 1px, transparent 1px 24px
  );
  animation: scroll 4s linear infinite;
  pointer-events: none;
}

@keyframes scroll {
  to { background-position: 24px 24px; }
}</textarea></div>
        </div>

        <div class="editor-box panel" id="box-js">
            <div class="header-bar" id="header-js">
                <div class="flex-center">
                    <span class="label" data-show="desktop">JS</span>
                    <span class="text-btn" data-lang="js">copy</span>
                </div>
                <div class="controls">
                    <span class="pill" data-show="mobile" data-mobile-view="console">CONSOLE</span>
                    <span class="pill" data-show="mobile" data-mobile-view="preview">PREVIEW</span>
                    <div class="traffic-btn btn-yellow" data-show="desktop" data-action="minimize" data-panel="js">
                        <svg viewBox="0 0 10 10"><path d="M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-green" data-show="desktop" data-action="fullscreen" data-panel="js">
                        <svg viewBox="0 0 10 10"><path d="M5,2 L5,8 M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-red" data-action="exit-fullscreen" data-panel="js" style="visibility:hidden">
                        <svg viewBox="0 0 10 10"><path d="M2,2 L8,8 M8,2 L2,8"/></svg>
                    </div>
                </div>
            </div>
            <div class="editor-content"><textarea id="code-js">console.log("Welcome to AeroCode!");

document.querySelector('button').onclick = () => {
  const a = document.createElement('a');
  a.href = 'https://slightknack.dev/aerocode.html';
  a.download = 'aerocode.html';
  a.click();
};</textarea></div>
        </div>

        <div class="bottom-toolbar header-bar">
            <div class="flex-center">
                <div class="mode-switcher segmented-control">
                    <span class="pill active" data-keymap="vim">VIM</span>
                    <span class="pill" data-keymap="default">NORMAL</span>
                    <span class="pill" data-keymap="plain">PLAIN</span>
                </div>
                <span class="label offline-label">OFFLINE</span>
                <span class="text-btn" id="layout-btn">mobile</span>
            </div>
            <div class="flex-gap">
                <span class="pill" id="new-btn">NEW</span>
                <span class="pill" id="share-btn">SHARE</span>
            </div>
        </div>
    </div>

    <div id="preview-strip" class="preview-strip"></div>
    <div class="preview">
        <div class="header-bar" data-show="mobile">
            <span class="label">PREVIEW</span>
            <div class="controls">
                <span class="pill" data-mobile-view="code">CODE</span>
                <span class="pill" data-mobile-view="console">CONSOLE</span>
            </div>
        </div>
        <div id="iframe-container" class="iframe-container">
            <iframe id="preview-frame" sandbox="allow-scripts allow-modals allow-same-origin allow-downloads"></iframe>
        </div>
        <div id="console-panel" class="console-panel panel">
            <div class="header-bar" id="console-header">
                <div class="flex-center">
                    <span class="label" id="console-label">CONSOLE</span>
                    <span class="console-badge" id="console-badge"></span>
                    <div class="console-filters segmented-control" data-show="desktop">
                        <span class="pill active" data-filter="all">ALL</span>
                        <span class="pill" data-filter="log">LOG</span>
                        <span class="pill" data-filter="warn">WARN</span>
                        <span class="pill" data-filter="error">ERR</span>
                    </div>
                    <span class="text-btn" id="console-copy">copy</span>
                    <span class="text-btn" id="console-clear">clear</span>
                </div>
                <div class="controls" data-show="desktop">
                    <div class="traffic-btn btn-yellow" data-action="console-collapse">
                        <svg viewBox="0 0 10 10"><path d="M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-green" data-action="console-fullscreen">
                        <svg viewBox="0 0 10 10"><path d="M5,2 L5,8 M2,5 L8,5"/></svg>
                    </div>
                </div>
                <div class="controls" data-show="mobile">
                    <span class="pill" data-mobile-view="preview">PREVIEW</span>
                    <span class="pill" data-mobile-view="code">CODE</span>
                </div>
            </div>
            <div class="console-body" id="console-body"></div>
            <div class="console-toolbar header-bar" data-show="mobile">
                <div class="console-filters segmented-control">
                    <span class="pill active" data-filter="all">CONSOLE</span>
                    <span class="pill" data-filter="log">LOG</span>
                    <span class="pill" data-filter="warn">WARN</span>
                    <span class="pill" data-filter="error">ERR</span>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/keymap/vim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/hint/xml-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/hint/html-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/hint/css-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/hint/javascript-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/closetag.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/matchtags.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/fold/xml-fold.min.js"></script>

    <script>
    // Layout constants
    const PANELS = ['html', 'css', 'js'];
    const HEADER_H = 32;
    const MIN_H = 56;           // min editor panel height when open
    const MIN_CONSOLE_H = 70;   // min console height (header + ~2 lines)
    const COLLAPSED_H = HEADER_H;
    const GAP = 8;
    const TOOLBAR_H = HEADER_H;
    const MIN_SIDEBAR_W = 375;
    const MIN_PREVIEW_W = 425;
    const DEFAULT_SIDEBAR_W = 500;
    const STRIP_W = 16;

    // Defaults read from textarea content (also works offline without JS)
    const DEFAULTS = {
        html: document.getElementById('code-html').value.trim(),
        css: document.getElementById('code-css').value.trim(),
        js: document.getElementById('code-js').value.trim()
    };

    // Application state (declarative model)
    const state = {
        sidebarWidth: DEFAULT_SIDEBAR_W,
        prevSidebarWidth: DEFAULT_SIDEBAR_W,
        collapsed: false,
        previewCollapsed: false,
        fullscreen: null,
        minimized: { html: false, css: false, js: false },
        heights: { html: 200, css: 200, js: 200 },
        clipboard: null,  // { type: 'share' | 'code' | 'console' | 'console-entry', lang?: string, entryIndex?: number } or null
        mobileView: 'preview',  // 'code' | 'preview' | 'console' - which view is active on mobile
        layout: 'auto',  // 'auto' | 'mobile' | 'desktop' - layout mode
        editorMode: 'vim'  // 'vim' | 'default' | 'plain'
    };

    // Layout detection
    const mobileQuery = window.matchMedia('(max-width: 800px)');
    function isMobile() {
        if (state.layout === 'mobile') return true;
        if (state.layout === 'desktop') return false;
        return mobileQuery.matches;
    }

    // Update body classes based on current layout state
    function updateLayoutClasses() {
        const mobile = isMobile();
        document.body.classList.toggle('layout-mobile', mobile);
        document.body.classList.toggle('layout-desktop', !mobile);

        // View classes only apply in mobile layout
        document.body.classList.toggle('view-code', mobile && state.mobileView === 'code');
        document.body.classList.toggle('view-preview', mobile && state.mobileView === 'preview');
        document.body.classList.toggle('view-console', mobile && state.mobileView === 'console');
    }

    // Console state
    const consoleState = {
        entries: [],      // { type, message, timestamp, line?, col? }
        expanded: true,   // panel open?
        height: 150,      // panel height in px
        filter: 'all',    // 'all' | 'log' | 'warn' | 'error'
        fullscreen: false // fullscreen mode?
    };

    // Generation counter to ignore messages from stale iframe executions
    let previewGeneration = 0;

    // Store error line markers for clearing
    let errorMarks = [];

    const dom = {};
    const editors = {};  // CodeMirror instances (or plain wrappers in offline mode)

    // Create plain textarea wrapper with CodeMirror-like API
    function createPlainEditor(lang) {
        const textarea = document.getElementById(`code-${lang}`);
        return {
            getValue: () => textarea.value,
            setValue: (val) => { textarea.value = val; },
            refresh: () => {},
            focus: () => textarea.focus(),
            setOption: () => {},
            on: (event, handler) => {
                if (event === 'change') {
                    textarea.addEventListener('input', handler);
                }
            },
            getWrapperElement: () => textarea.parentElement
        };
    }

    // Switch between VIM, NORMAL, and PLAIN editor modes
    function switchEditorMode(mode) {
        const prevMode = state.editorMode;
        state.editorMode = mode;

        if (mode === 'plain') {
            // Switch to plain textareas
            document.body.classList.add('plain-mode');
            PANELS.forEach(lang => {
                const textarea = document.getElementById(`code-${lang}`);
                // Sync content from CodeMirror to textarea
                if (hasCodeMirror && editors[lang]) {
                    textarea.value = editors[lang].getValue();
                }
                // Show textarea, hide CodeMirror
                textarea.style.display = 'block';
                if (editors[lang]) {
                    editors[lang].getWrapperElement().style.display = 'none';
                }
            });
        } else {
            // Switch to CodeMirror (if available)
            document.body.classList.remove('plain-mode');
            if (hasCodeMirror) {
                PANELS.forEach(lang => {
                    const textarea = document.getElementById(`code-${lang}`);
                    // Sync content from textarea to CodeMirror
                    if (editors[lang]) {
                        editors[lang].setValue(textarea.value);
                        editors[lang].getWrapperElement().style.display = '';
                        editors[lang].setOption('keyMap', mode);
                        editors[lang].refresh();
                    }
                    textarea.style.display = 'none';
                });
            }
        }
    }

    // Geometry helpers
    function getUsableHeight() {
        return dom.sidebar.clientHeight - TOOLBAR_H;
    }

    function getEffectiveHeight(panel) {
        return state.minimized[panel] ? COLLAPSED_H : state.heights[panel];
    }

    // Ensure panels fit within available space
    function enforceConstraints() {
        const usable = getUsableHeight();
        const totalGaps = (PANELS.length + 1) * GAP;
        const availableForPanels = usable - totalGaps;

        const openPanels = PANELS.filter(p => !state.minimized[p]);
        const minimizedCount = PANELS.length - openPanels.length;
        const spaceForOpen = availableForPanels - minimizedCount * COLLAPSED_H;

        if (openPanels.length === 0) return;

        // Ensure minimum heights
        openPanels.forEach(p => {
            state.heights[p] = Math.max(MIN_H, state.heights[p]);
        });

        let currentOpenTotal = openPanels.reduce((sum, p) => sum + state.heights[p], 0);
        const diff = spaceForOpen - currentOpenTotal;

        if (diff === 0) return;

        if (diff < 0) {
            // Need to shrink - take from panels proportionally
            let toShrink = -diff;
            while (toShrink > 0) {
                const shrinkable = openPanels.filter(p => state.heights[p] > MIN_H);
                if (shrinkable.length === 0) break;

                const perPanel = Math.ceil(toShrink / shrinkable.length);
                for (const p of shrinkable) {
                    const canTake = Math.min(perPanel, state.heights[p] - MIN_H, toShrink);
                    state.heights[p] -= canTake;
                    toShrink -= canTake;
                    if (toShrink <= 0) break;
                }
            }
        } else {
            // Need to grow - give extra to last open panel
            const last = openPanels[openPanels.length - 1];
            state.heights[last] += diff;
        }
    }

    function initializeHeights() {
        const usable = getUsableHeight();
        const totalGaps = (PANELS.length + 1) * GAP;
        const available = usable - totalGaps;
        const heightPerPanel = Math.floor(available / PANELS.length);
        const remainder = available - (heightPerPanel * PANELS.length);

        PANELS.forEach((p, i) => {
            state.heights[p] = heightPerPanel;
            // Give remainder to last panel
            if (i === PANELS.length - 1) {
                state.heights[p] += remainder;
            }
        });
    }

    // Segmented control: update slider position
    function updateSegmentedSlider(container) {
        const active = container.querySelector('.pill.active');
        if (!active) return;
        container.style.setProperty('--active-left', `${active.offsetLeft - 3}px`);
        container.style.setProperty('--active-width', `${active.offsetWidth}px`);
    }

    function updateAllSegmentedSliders() {
        document.querySelectorAll('.segmented-control').forEach(updateSegmentedSlider);
    }

    // Render: derive DOM from state
    function render() {
        const maxW = window.innerWidth;
        const mobile = isMobile();

        // Update layout classes on body
        updateLayoutClasses();

        // Force fullscreen/tabbed mode on mobile - default to HTML if nothing selected
        if (mobile && !state.fullscreen) {
            state.fullscreen = 'html';
        }

        // Handle sidebar collapsed (desktop only)
        if (!mobile && state.collapsed) {
            dom.sidebar.classList.add('hidden');
            dom.strip.style.display = 'block';
        } else {
            dom.sidebar.classList.remove('hidden');
            dom.strip.style.display = mobile ? 'none' : 'none';
            if (!mobile) {
                dom.sidebar.style.width = `${state.sidebarWidth}px`;
            }
        }

        // Handle preview collapsed (desktop only)
        if (!mobile && state.previewCollapsed) {
            dom.previewContainer.classList.add('hidden');
            dom.previewStrip.style.display = 'block';
        } else {
            dom.previewContainer.classList.remove('hidden');
            dom.previewStrip.style.display = 'none';
        }

        // Early return if sidebar is collapsed (desktop only)
        if (!mobile && state.collapsed) return;

        if (state.fullscreen) {
            dom.sidebar.classList.add('fullscreen-mode');
            PANELS.forEach(p => {
                const box = dom.boxes[p];
                const isActive = p === state.fullscreen;
                box.classList.toggle('fs-active', isActive);
                box.querySelector('.btn-red').style.visibility = isActive ? 'visible' : 'hidden';
                box.querySelector('.btn-green').style.visibility = isActive ? 'hidden' : 'visible';
                box.querySelector('.btn-yellow').style.visibility = isActive ? 'hidden' : 'visible';
            });

            // Update lang-switcher pill active states
            const langSwitcher = document.getElementById('lang-switcher');
            if (langSwitcher) {
                langSwitcher.querySelectorAll('.pill').forEach(pill => {
                    pill.classList.toggle('active', pill.dataset.panel === state.fullscreen);
                });
                updateSegmentedSlider(langSwitcher);
            }

            // Update fs-copy button data attribute
            const fsCopy = document.getElementById('fs-copy');
            if (fsCopy) {
                fsCopy.dataset.lang = state.fullscreen;
            }
        } else {
            dom.sidebar.classList.remove('fullscreen-mode');

            let top = GAP;
            PANELS.forEach(p => {
                const h = getEffectiveHeight(p);
                const box = dom.boxes[p];

                box.classList.remove('fs-active');
                box.style.top = `${top}px`;
                box.style.height = `${h}px`;
                box.style.bottom = 'auto';

                box.querySelector('.btn-red').style.visibility = 'hidden';
                box.querySelector('.btn-green').style.visibility = 'visible';
                box.querySelector('.btn-yellow').style.visibility = 'visible';

                document.getElementById(`header-${p}`).style.cursor = p === 'html' ? 'pointer' : 'row-resize';

                top += h + GAP;
            });
        }

        requestAnimationFrame(() => {
            Object.values(editors).forEach(cm => cm.refresh());
        });

        // Layout button - shows what clicking will toggle TO
        const layoutBtn = document.getElementById('layout-btn');
        const currentlyMobile = isMobile();
        layoutBtn.textContent = currentlyMobile ? 'desktop' : 'mobile';
        // Show active state when layout is forced (not auto)
        layoutBtn.classList.toggle('active', state.layout !== 'auto');

        // Clipboard button states
        const updateBtn = (btn, active, activeText, normalText) => {
            btn.classList.toggle('active', active);
            btn.textContent = active ? activeText : normalText;
        };

        updateBtn(document.getElementById('share-btn'), state.clipboard?.type === 'share', 'COPIED URL', 'SHARE');
        document.querySelectorAll('.text-btn[data-lang]').forEach(btn =>
            updateBtn(btn, state.clipboard?.type === 'code' && state.clipboard.lang === btn.dataset.lang, 'copied!', 'copy')
        );
        updateBtn(document.getElementById('console-copy'), state.clipboard?.type === 'console', 'copied!', 'copy');

        // Re-render console to update copied entry state
        renderConsole();
    }

    // Panel actions
    function toggleMinimize(panel) {
        const idx = PANELS.indexOf(panel);

        if (!state.minimized[panel]) {
            const freedSpace = state.heights[panel] - COLLAPSED_H;
            state.minimized[panel] = true;

            let recipient = PANELS.slice(idx + 1).find(p => !state.minimized[p]);
            if (!recipient) recipient = PANELS.slice(0, idx).reverse().find(p => !state.minimized[p]);
            if (recipient) state.heights[recipient] += freedSpace;
        } else {
            const neededSpace = state.heights[panel] - COLLAPSED_H;
            state.minimized[panel] = false;

            const othersOpen = PANELS.filter(p => p !== panel && !state.minimized[p]);
            if (othersOpen.length === 0) {
                const usable = getUsableHeight();
                const totalGaps = (PANELS.length + 1) * GAP;
                state.heights[panel] = usable - totalGaps - (PANELS.length - 1) * COLLAPSED_H;
            } else {
                let remaining = neededSpace;
                for (const p of PANELS.slice(idx + 1)) {
                    if (state.minimized[p] || remaining <= 0) continue;
                    const canTake = Math.min(remaining, state.heights[p] - MIN_H);
                    state.heights[p] -= canTake;
                    remaining -= canTake;
                }
                for (const p of PANELS.slice(0, idx).reverse()) {
                    if (state.minimized[p] || remaining <= 0) continue;
                    const canTake = Math.min(remaining, state.heights[p] - MIN_H);
                    state.heights[p] -= canTake;
                    remaining -= canTake;
                }
            }
        }
        render();
    }

    function toggleFullscreen(panel) {
        state.fullscreen = (state.fullscreen === panel) ? null : panel;
        if (state.fullscreen) state.minimized[panel] = false;
        render();
    }

    function switchFullscreenPanel(panel) {
        // On mobile or in fullscreen mode, switch to the requested panel
        if (state.fullscreen || isMobile()) {
            state.fullscreen = panel;
            render();
        }
    }

    function computeDragState(startState, draggedPanel, delta) {
        const panelIdx = PANELS.indexOf(draggedPanel);
        const newState = {
            minimized: { ...startState.minimized },
            heights: { ...startState.heights }
        };

        if (startState.minimized[draggedPanel]) return newState;

        if (delta < 0) {
            let toGrow = -delta;
            for (let i = panelIdx - 1; i >= 0 && toGrow > 0; i--) {
                const p = PANELS[i];
                if (startState.minimized[p]) continue;

                const canTake = newState.heights[p] - MIN_H;
                const take = Math.min(canTake, toGrow);
                newState.heights[p] -= take;
                toGrow -= take;
            }

            // Grow this panel by amount we took
            newState.heights[draggedPanel] = startState.heights[draggedPanel] + (-delta - toGrow);

        } else if (delta > 0) {
            // Dragging down: shrink this panel AND push panels below
            // First, shrink this panel
            const canShrink = startState.heights[draggedPanel] - MIN_H;
            const shrinkSelf = Math.min(canShrink, delta);
            newState.heights[draggedPanel] = startState.heights[draggedPanel] - shrinkSelf;

            // Remaining delta pushes panels below (shrinks them)
            let remaining = delta - shrinkSelf;
            for (let i = panelIdx + 1; i < PANELS.length && remaining > 0; i++) {
                const p = PANELS[i];
                if (startState.minimized[p]) continue;

                const canTake = newState.heights[p] - MIN_H;
                const take = Math.min(canTake, remaining);
                newState.heights[p] -= take;
                remaining -= take;
            }

            // Give the freed space to the panel above
            const freedSpace = delta - remaining;
            for (let i = panelIdx - 1; i >= 0; i--) {
                const p = PANELS[i];
                if (startState.minimized[p]) continue;
                newState.heights[p] = startState.heights[p] + freedSpace;
                break;
            }
        }

        return newState;
    }

    // Event binding
    function bindEvents() {
        dom.resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const startWidth = state.sidebarWidth;

            startDrag('col-resize', (em) => {
                const newW = em.clientX;
                const maxW = window.innerWidth;
                const previewW = maxW - newW;

                if (newW < 50) {
                    // Snap sidebar closed
                    state.prevSidebarWidth = startWidth;
                    state.collapsed = true;
                    state.previewCollapsed = false;
                } else if (previewW < 50) {
                    // Snap preview closed
                    state.previewCollapsed = true;
                    state.sidebarWidth = maxW - STRIP_W;
                } else {
                    state.collapsed = false;
                    state.previewCollapsed = false;
                    state.sidebarWidth = Math.max(MIN_SIDEBAR_W, Math.min(newW, maxW - MIN_PREVIEW_W));
                }
                render();
            });
        });

        bindSidebarStripDrag();
        bindPreviewStripDrag();

        PANELS.forEach(panel => {
            const header = document.getElementById(`header-${panel}`);
            header.addEventListener('mousedown', (e) => {
                if (e.target.closest('.controls') || e.target.closest('.fs-nav') || e.target.closest('.text-btn')) return;
                e.preventDefault();

                if (panel === 'html') {
                    toggleMinimize('html');
                    return;
                }

                const startY = e.clientY;
                const startState = {
                    minimized: { ...state.minimized },
                    heights: { ...state.heights }
                };
                let isDrag = false;

                startDrag('row-resize', (em) => {
                    const delta = em.clientY - startY;
                    if (Math.abs(delta) > 3) isDrag = true;
                    if (!isDrag) return;

                    const newState = computeDragState(startState, panel, delta);
                    state.minimized = newState.minimized;
                    state.heights = newState.heights;
                    enforceConstraints();
                    render();
                }, () => {
                    if (!isDrag) toggleMinimize(panel);
                });
            });
        });

        document.querySelectorAll('.traffic-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const action = btn.dataset.action;
                const panel = btn.dataset.panel;
                if (action === 'minimize') toggleMinimize(panel);
                else if (action === 'fullscreen' || action === 'exit-fullscreen') toggleFullscreen(panel);
                else if (action === 'console-collapse') {
                    consoleState.expanded = !consoleState.expanded;
                    consoleState.fullscreen = false;
                    renderConsole();
                }
                else if (action === 'console-fullscreen') {
                    consoleState.fullscreen = !consoleState.fullscreen;
                    consoleState.expanded = true;
                    renderConsole();
                }
            });
        });

        document.querySelectorAll('.fs-nav .pill').forEach(tag => {
            tag.addEventListener('click', (e) => {
                e.stopPropagation();
                switchFullscreenPanel(tag.dataset.panel);
            });
        });

        document.querySelectorAll('.text-btn[data-lang]').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                e.stopPropagation();
                const lang = btn.dataset.lang;
                await copyToClipboard(editors[lang].getValue());
                state.clipboard = { type: 'code', lang };
                render();
            });
        });

        document.querySelectorAll('.segmented-control').forEach(container => {
            // Initialize slider position
            updateSegmentedSlider(container);

            // Update on click
            container.querySelectorAll('.pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    container.querySelectorAll('.pill').forEach(p => p.classList.remove('active'));
                    pill.classList.add('active');
                    updateSegmentedSlider(container);
                });
            });
        });

        // Mode switcher specific logic (keymap change)
        document.querySelectorAll('.mode-switcher .pill').forEach(tag => {
            tag.addEventListener('click', () => {
                const mode = tag.dataset.keymap;
                switchEditorMode(mode);
            });
        });

        document.getElementById('layout-btn').addEventListener('click', () => {
            // Toggle to the opposite layout, or back to auto if already forced
            const currentlyMobile = isMobile();
            if (state.layout === 'auto') {
                // Force to opposite of current
                state.layout = currentlyMobile ? 'desktop' : 'mobile';
            } else {
                // Return to auto
                state.layout = 'auto';
            }
            render();
            requestAnimationFrame(() => {
                Object.values(editors).forEach(cm => cm.refresh());
                updateAllSegmentedSliders();
            });
        });

        document.getElementById('new-btn').addEventListener('click', () => {
            if (!confirm('Clear all code and start fresh?')) return;

            editors.html.setValue('');
            editors.css.setValue('');
            editors.js.setValue('');

            state.collapsed = false;
            state.fullscreen = null;
            state.minimized = { html: false, css: false, js: false };
            state.clipboard = null;
            initializeHeights();

            history.replaceState(null, '', location.pathname);

            render();
            updatePreview();
        });

        document.getElementById('share-btn').addEventListener('click', async () => {
            await updateUrl();
            await copyToClipboard(window.location.href);
            state.clipboard = { type: 'share' };
            render();
        });

        // Console panel event handlers
        document.getElementById('console-copy').addEventListener('click', async (e) => {
            e.stopPropagation();
            const text = consoleState.entries.map(entry => {
                const time = new Date(entry.timestamp).toLocaleTimeString('en-US', { hour12: false });
                return `[${time}] [${entry.type.toUpperCase()}] ${entry.message}`;
            }).join('\n');

            await copyToClipboard(text);
            state.clipboard = { type: 'console' };
            render();
        });

        document.getElementById('console-clear').addEventListener('click', (e) => {
            e.stopPropagation();
            consoleState.entries = [];
            clearErrorMarks();
            // Clear clipboard if it was console-related
            if (state.clipboard?.type === 'console' || state.clipboard?.type === 'console-entry') {
                state.clipboard = null;
            }
            render();
        });



        document.querySelectorAll('.console-filters .pill').forEach(filter => {
            filter.addEventListener('click', (e) => {
                e.stopPropagation();
                consoleState.filter = filter.dataset.filter;
                renderConsole();
            });
        });

        // Console line click to jump to error, type badge click to copy
        document.getElementById('console-body').addEventListener('click', async (e) => {
            const lineEl = e.target.closest('.console-line');
            if (lineEl) {
                const line = parseInt(lineEl.dataset.line, 10);
                jumpToLine(line);
                return;
            }

            // Click on type badge to copy that entry
            const typeEl = e.target.closest('.console-type');
            if (typeEl) {
                const entryEl = e.target.closest('.console-entry');
                const index = parseInt(entryEl.dataset.index, 10);
                const entry = consoleState.entries[index];
                if (entry) {
                    await copyToClipboard(entry.message);
                    state.clipboard = { type: 'console-entry', entryIndex: index, entryType: entry.type };
                    render();
                    renderConsole();
                }
            }
        });

        // Console header drag to resize (with snap-to-close and snap-to-fullscreen)
        document.getElementById('console-header').addEventListener('mousedown', (e) => {
            if (isMobile()) return; // No drag/collapse on mobile
            if (e.target.closest('.controls') || e.target.closest('.console-filters') || e.target.closest('.text-btn')) return;
            e.preventDefault();
            const startY = e.clientY;
            const previewHeight = document.querySelector('.preview').clientHeight;
            const startHeight = consoleState.fullscreen
                ? previewHeight
                : (consoleState.expanded ? consoleState.height : HEADER_H);
            let isDrag = false;

            startDrag('row-resize', (em) => {
                const delta = startY - em.clientY;
                if (Math.abs(delta) > 3) isDrag = true;
                if (!isDrag) return;

                const newHeight = startHeight + delta;

                // Snap to fullscreen if dragged near top
                if (newHeight > previewHeight - 50) {
                    consoleState.fullscreen = true;
                    consoleState.expanded = true;
                }
                // Snap closed if dragged below threshold
                else if (newHeight < MIN_CONSOLE_H) {
                    consoleState.expanded = false;
                    consoleState.fullscreen = false;
                } else {
                    consoleState.expanded = true;
                    consoleState.fullscreen = false;
                    consoleState.height = newHeight;
                }
                renderConsole();
            }, () => {
                // Click without drag toggles expand
                if (!isDrag) {
                    consoleState.expanded = !consoleState.expanded;
                    consoleState.fullscreen = false;
                    renderConsole();
                }
            });
        });

        window.addEventListener('resize', () => {
            const maxW = window.innerWidth;

            // Enforce sidebar/preview width constraints on window resize
            if (state.collapsed) {
                // Sidebar collapsed - nothing to constrain
            } else if (state.previewCollapsed) {
                // Preview collapsed - sidebar takes full width minus strip
                state.sidebarWidth = maxW - STRIP_W;
            } else {
                // Both visible - enforce min widths
                // If window too small for both, prioritize preview
                const maxSidebarW = maxW - MIN_PREVIEW_W;
                if (maxSidebarW < MIN_SIDEBAR_W) {
                    // Window too small - collapse sidebar
                    state.prevSidebarWidth = state.sidebarWidth;
                    state.collapsed = true;
                } else {
                    state.sidebarWidth = Math.max(MIN_SIDEBAR_W, Math.min(state.sidebarWidth, maxSidebarW));
                }
            }

            enforceConstraints();
            render();
            updateAllSegmentedSliders();
        });

        // Mobile view navigation pills
        const withoutTransitions = (fn) => {
            const controls = document.querySelectorAll('.segmented-control');
            controls.forEach(c => c.style.setProperty('--slider-transition', 'none'));
            fn();
            updateAllSegmentedSliders();
            requestAnimationFrame(() => controls.forEach(c => c.style.removeProperty('--slider-transition')));
        };

        document.querySelectorAll('[data-mobile-view]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                state.mobileView = btn.dataset.mobileView;
                withoutTransitions(render);
                if (state.mobileView === 'code') Object.values(editors).forEach(cm => cm.refresh());
            });
        });

        // Listen for media query changes to handle orientation/resize
        mobileQuery.addEventListener('change', () => {
            render();
            requestAnimationFrame(updateAllSegmentedSliders);
        });
    }

    function startDrag(cursor, onMove, onUp = () => {}) {
        dom.overlay.style.display = 'block';
        dom.overlay.style.cursor = cursor;
        document.body.style.cursor = cursor;

        const moveHandler = (em) => onMove(em);
        const upHandler = () => {
            window.removeEventListener('mousemove', moveHandler);
            window.removeEventListener('mouseup', upHandler);
            dom.overlay.style.display = 'none';
            document.body.style.cursor = '';
            onUp();
        };

        window.addEventListener('mousemove', moveHandler);
        window.addEventListener('mouseup', upHandler);
    }

    function bindSidebarStripDrag() {
        dom.strip.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const startX = e.clientX;
            const startWidth = state.prevSidebarWidth || DEFAULT_SIDEBAR_W;
            let isDrag = false;

            startDrag('col-resize', (em) => {
                if (Math.abs(em.clientX - startX) > 3) isDrag = true;
                if (!isDrag) return;

                const newW = em.clientX;
                const maxW = window.innerWidth;

                if (newW < 50) {
                    state.prevSidebarWidth = startWidth;
                    state.collapsed = true;
                } else {
                    state.collapsed = false;
                    state.sidebarWidth = (newW > maxW - 30) ? maxW - STRIP_W : Math.max(MIN_SIDEBAR_W, newW);
                }
                render();
            }, () => {
                if (!isDrag) {
                    state.collapsed = false;
                    state.sidebarWidth = state.prevSidebarWidth;
                    render();
                }
            });
        });
    }

    function bindPreviewStripDrag() {
        dom.previewStrip.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const startX = e.clientX;
            const maxW = window.innerWidth;
            let isDrag = false;

            startDrag('col-resize', (em) => {
                if (Math.abs(em.clientX - startX) > 3) isDrag = true;
                if (!isDrag) return;

                const newW = em.clientX;
                const previewW = maxW - newW;

                if (previewW < 50) {
                    // Keep preview collapsed
                    state.previewCollapsed = true;
                    state.sidebarWidth = maxW - STRIP_W;
                } else if (newW < 50) {
                    // Snap sidebar closed, restore preview
                    state.previewCollapsed = false;
                    state.prevSidebarWidth = state.sidebarWidth;
                    state.collapsed = true;
                } else {
                    // Restore preview
                    state.previewCollapsed = false;
                    state.sidebarWidth = Math.max(MIN_SIDEBAR_W, Math.min(newW, maxW - MIN_PREVIEW_W));
                }
                render();
            }, () => {
                if (!isDrag) {
                    // Click to restore preview
                    state.previewCollapsed = false;
                    state.sidebarWidth = Math.min(state.sidebarWidth, maxW - MIN_PREVIEW_W);
                    render();
                }
            });
        });
    }

    // Preview and URL state
    let urlTimeout = null;

    function buildInterceptor(generation) {
        return `
(function() {
    const GEN = ${generation};
    const _log = console.log, _warn = console.warn,
          _error = console.error, _info = console.info;

    function send(type, args) {
        try {
            parent.postMessage({
                source: 'aerocode-console',
                gen: GEN,
                type: type,
                message: Array.from(args).map(a => {
                    if (a === undefined) return 'undefined';
                    if (a === null) return 'null';
                    if (typeof a === 'object') {
                        try { return JSON.stringify(a, null, 2); }
                        catch { return String(a); }
                    }
                    return String(a);
                }).join(' '),
                timestamp: Date.now()
            }, '*');
        } catch(e) {}
    }

    console.log = function() { _log.apply(console, arguments); send('log', arguments); };
    console.warn = function() { _warn.apply(console, arguments); send('warn', arguments); };
    console.error = function() { _error.apply(console, arguments); send('error', arguments); };
    console.info = function() { _info.apply(console, arguments); send('info', arguments); };

    window.onerror = function(msg, url, line, col, err) {
        parent.postMessage({
            source: 'aerocode-console',
            gen: GEN,
            type: 'error',
            message: msg + (err && err.stack ? '\\n' + err.stack : ''),
            timestamp: Date.now(),
            line: line,
            col: col
        }, '*');
        return false;
    };

    window.addEventListener('unhandledrejection', function(e) {
        parent.postMessage({
            source: 'aerocode-console',
            gen: GEN,
            type: 'error',
            message: 'Unhandled Promise Rejection: ' + (e.reason ? e.reason.message || e.reason : 'Unknown'),
            timestamp: Date.now()
        }, '*');
    });
})();`;
    }

    function updatePreview() {
        // Increment generation to ignore messages from previous iframe executions
        const generation = ++previewGeneration;

        // Clear previous console entries and error marks
        consoleState.entries = [];
        clearErrorMarks();
        renderConsole();

        // Get content from appropriate source based on editor mode
        const getContent = (lang) => {
            if (state.editorMode === 'plain') {
                return document.getElementById(`code-${lang}`).value;
            }
            return editors[lang].getValue();
        };
        const html = getContent('html');
        const css = getContent('css');
        const js = getContent('js');

        // Use data URIs to avoid injection issues with closing script tags in user code
        const cssDataUri = 'data:text/css,' + encodeURIComponent(css);
        const jsDataUri = 'data:text/javascript,' + encodeURIComponent(js + '\n//# sourceURL=usercode.js');

        const doc = dom.preview.contentDocument;
        doc.open();
        doc.write(
            '<!DOCTYPE html><html><head>' +
            '<link rel="stylesheet" href="' + cssDataUri + '">' +
            '<scr' + 'ipt>' + buildInterceptor(generation) + '</scr' + 'ipt>' +
            '<scr' + 'ipt defer src="' + jsDataUri + '"></scr' + 'ipt>' +
            '</head><body>' + html + '</body></html>'
        );
        doc.close();

        scheduleUrlUpdate();
    }

    function scheduleUrlUpdate() {
        clearTimeout(urlTimeout);
        urlTimeout = setTimeout(updateUrl, 500);
    }

    async function updateUrl() {
        try {
            const h = editors.html.getValue();
            const c = editors.css.getValue();
            const j = editors.js.getValue();

            // If content matches defaults, clear the hash
            if (h === DEFAULTS.html && c === DEFAULTS.css && j === DEFAULTS.js) {
                history.replaceState(null, '', location.pathname);
                return;
            }

            // p=1 means "start in preview mode" (mobile: preview tab, desktop: sidebar collapsed)
            const previewMode = isMobile() ? (state.mobileView === 'preview') : state.collapsed;
            const data = { h, c, j, p: previewMode ? 1 : 0 };
            const json = JSON.stringify(data);
            const compressed = await new Response(new Blob([json]).stream().pipeThrough(new CompressionStream('gzip'))).arrayBuffer();
            const encoded = btoa(String.fromCharCode(...new Uint8Array(compressed)));
            history.replaceState(null, '', `${location.pathname}#${encoded}`);
        } catch (err) {}
    }

    async function loadFromHash() {
        const hash = location.hash.slice(1);
        if (!hash) return false;
        try {
            const bytes = Uint8Array.from(atob(hash), c => c.charCodeAt(0));
            const json = await new Response(new Blob([bytes]).stream().pipeThrough(new DecompressionStream('gzip'))).text();
            const data = JSON.parse(json);

            if (data.h !== undefined) editors.html.setValue(data.h);
            if (data.c !== undefined) editors.css.setValue(data.c);
            if (data.j !== undefined) editors.js.setValue(data.j);

            // Apply preview mode flag (backwards compatible with old s/f format)
            if (data.p !== undefined) {
                const previewMode = data.p === 1;
                state.mobileView = previewMode ? 'preview' : 'code';
                state.collapsed = previewMode;
            } else {
                // Legacy support: convert old s/f to new p behavior
                if (data.s !== undefined) state.collapsed = data.s === 0;
                state.mobileView = state.collapsed ? 'preview' : 'code';
            }

            render();
            return true;
        } catch (e) {
            return false;
        }
    }

    // Console functions
    function clearErrorMarks() {
        errorMarks.forEach(mark => mark.clear());
        errorMarks = [];
    }

    function markErrorLine(line) {
        if (!line || line < 1) return;
        const lineIndex = line - 1; // CodeMirror uses 0-based indexing
        const cm = editors.js;
        if (lineIndex >= cm.lineCount()) return;

        const mark = cm.markText(
            { line: lineIndex, ch: 0 },
            { line: lineIndex, ch: cm.getLine(lineIndex).length },
            { className: 'cm-error-line' }
        );
        errorMarks.push(mark);
    }

    function jumpToLine(line) {
        if (!line || line < 1) return;
        const lineIndex = line - 1;
        const cm = editors.js;

        // On mobile, switch to code view
        if (isMobile()) {
            state.mobileView = 'code';
        }

        // Expand sidebar if collapsed (desktop)
        if (state.collapsed) {
            state.collapsed = false;
        }

        // Switch to JS panel
        if (state.fullscreen !== 'js') {
            state.fullscreen = 'js';
        }

        render();

        // Focus and scroll to line (after render to ensure visibility)
        requestAnimationFrame(() => {
            cm.refresh();
            cm.focus();
            cm.setCursor({ line: lineIndex, ch: 0 });
            cm.scrollIntoView({ line: lineIndex, ch: 0 }, 100);
        });
    }

    function formatTime(timestamp) {
        const d = new Date(timestamp);
        return d.toLocaleTimeString('en-US', { hour12: false });
    }

    function renderConsole() {
        const panel = document.getElementById('console-panel');
        const body = document.getElementById('console-body');
        const badge = document.getElementById('console-badge');

        if (!panel) return;

        // Set panel height and states
        if (consoleState.fullscreen) {
            panel.style.height = '';
            panel.classList.remove('collapsed');
            panel.classList.add('fullscreen');
        } else if (consoleState.expanded) {
            panel.style.height = `${consoleState.height}px`;
            panel.classList.remove('collapsed', 'fullscreen');
        } else {
            panel.style.height = `${HEADER_H}px`;
            panel.classList.add('collapsed');
            panel.classList.remove('fullscreen');
        }

        // Update badge
        const errorCount = consoleState.entries.filter(e => e.type === 'error').length;
        const totalCount = consoleState.entries.length;
        badge.textContent = totalCount;
        badge.classList.toggle('has-errors', errorCount > 0);

        // Update filter buttons
        document.querySelectorAll('.console-filters .pill').forEach(f => {
          f.classList.toggle('active', f.dataset.filter === consoleState.filter);
        });

        // Update segmented control sliders for console filters
        document.querySelectorAll('.console-filters.segmented-control').forEach(updateSegmentedSlider);

        // Swap green/red button based on fullscreen state
        const consoleGreen = panel.querySelector('.traffic-btn[data-action="console-fullscreen"]');
        if (consoleGreen) {
            if (consoleState.fullscreen) {
                consoleGreen.classList.remove('btn-green');
                consoleGreen.classList.add('btn-red');
                consoleGreen.innerHTML = '<svg viewBox="0 0 10 10"><path d="M2,2 L8,8 M8,2 L2,8"/></svg>';
            } else {
                consoleGreen.classList.remove('btn-red');
                consoleGreen.classList.add('btn-green');
                consoleGreen.innerHTML = '<svg viewBox="0 0 10 10"><path d="M5,2 L5,8 M2,5 L8,5"/></svg>';
            }
        }

        // Filter entries with original indices
        const filtered = consoleState.entries
            .map((e, i) => ({ ...e, originalIndex: i }))
            .filter(e => consoleState.filter === 'all' || e.type === consoleState.filter);

        // Group consecutive duplicates
        const grouped = [];
        for (const entry of filtered) {
            const last = grouped[grouped.length - 1];
            if (last && last.type === entry.type && last.message === entry.message) {
                last.count++;
                last.timestamp = entry.timestamp;
            } else {
                grouped.push({ ...entry, count: 1 });
            }
        }

        // Render entries
        if (grouped.length === 0) {
            body.innerHTML = '<div class="console-empty">No console output</div>';
        } else {
            body.innerHTML = grouped.map(({ type, message, timestamp, line, count, originalIndex }) => {
                const isCopied = state.clipboard?.type === 'console-entry' && state.clipboard.entryIndex === originalIndex;
                return `
                    <div class="console-entry ${type}" data-index="${originalIndex}">
                        <span class="console-time">${formatTime(timestamp)}</span>
                        <span class="console-type ${type}${isCopied ? ' copied' : ''}">${isCopied ? `COPIED ${type.toUpperCase()}` : type.toUpperCase()}</span>
                        <span class="console-message">${escapeHtml(message)}</span>
                        ${count > 1 ? `<span class="console-count">${count}</span>` : ''}
                        ${line ? `<span class="console-line" data-line="${line}">:${line}</span>` : ''}
                    </div>
                `;
            }).join('');

            // Auto-scroll to bottom
            body.scrollTop = body.scrollHeight;
        }
    }

    function escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    async function copyToClipboard(text) {
        try {
            await navigator.clipboard.writeText(text);
        } catch (err) {
            const tmp = document.createElement('textarea');
            tmp.value = text;
            tmp.style.position = 'fixed';
            tmp.style.opacity = '0';
            document.body.appendChild(tmp);
            tmp.focus();
            tmp.select();
            document.execCommand('copy');
            document.body.removeChild(tmp);
        }
    }

    // Message listener for console output from iframe
    window.addEventListener('message', (e) => {
        if (e.data && e.data.source === 'aerocode-console') {
            // Ignore messages from stale iframe executions
            if (e.data.gen !== previewGeneration) return;

            // Extract line number from error
            // Stack traces show usercode.js:LINE where LINE is 1-based user code line
            let line = null;
            if (e.data.type === 'error' && e.data.message) {
                const match = e.data.message.match(/usercode\.js:(\d+)/);
                if (match) {
                    line = parseInt(match[1], 10);
                }
            }
            // Fallback to window.onerror line (but this is raw doc line, less reliable)
            if (!line && e.data.line) {
                line = e.data.line;
            }

            consoleState.entries.push({ ...e.data, line });
            renderConsole();

            // Mark error line in editor
            if (e.data.type === 'error' && line && line > 0) {
                markErrorLine(line);
            }
        }
    });

    // Check if CodeMirror loaded
    const hasCodeMirror = typeof CodeMirror !== 'undefined';

    function onCodeChange() {
        updatePreview();
        if (state.clipboard !== null) {
            state.clipboard = null;
            render();
        }
    }

    function init() {
        dom.sidebar = document.getElementById('sidebar');
        dom.strip = document.getElementById('sidebar-strip');
        dom.previewStrip = document.getElementById('preview-strip');
        dom.previewContainer = document.querySelector('.preview');
        dom.iframeContainer = document.getElementById('iframe-container');
        dom.overlay = document.getElementById('drag-overlay');
        dom.preview = document.getElementById('preview-frame');
        dom.resizer = document.getElementById('sidebar-resizer');
        dom.boxes = {
            html: document.getElementById('box-html'),
            css: document.getElementById('box-css'),
            js: document.getElementById('box-js')
        };

        if (hasCodeMirror) {
            initWithCodeMirror();
        } else {
            initFallback();
        }

        // Textarea input handlers (for plain mode or offline)
        PANELS.forEach(lang => {
            document.getElementById(`code-${lang}`).addEventListener('input', () => {
                if (state.editorMode === 'plain') onCodeChange();
            });
        });

        initializeHeights();
        bindEvents();
        render();
        renderConsole();

        loadFromHash().then(() => {
            updatePreview();
            // CodeMirror change handlers
            if (hasCodeMirror) {
                PANELS.forEach(lang => editors[lang].on('change', onCodeChange));
            }
        });
    }

    function handleTab(cm, lang) {
        if (lang === 'html') {
            const cursor = cm.getCursor();
            const line = cm.getLine(cursor.line);
            const match = line.slice(0, cursor.ch).match(/<([a-zA-Z][a-zA-Z0-9]*)\s*$/);
            if (match) {
                const tag = match[1];
                const voidTags = ['area','base','br','col','embed','hr','img','input','link','meta','param','source','track','wbr'];
                cm.replaceRange(voidTags.includes(tag.toLowerCase()) ? '>' : `></${tag}>`, cursor);
                if (!voidTags.includes(tag.toLowerCase())) cm.setCursor({ line: cursor.line, ch: cursor.ch + 1 });
                return;
            }
        }
        cm.somethingSelected() ? cm.indentSelection('add') : cm.replaceSelection('  ', 'end');
    }

    function initWithCodeMirror() {
        const modes = { html: 'htmlmixed', css: 'css', js: 'javascript' };
        const triggerChars = {
            html: ['<', '/', '"', '=', ' '],
            css: [':', ';', '{', '.', '#', ' '],
            js: ['.']
        };

        PANELS.forEach(lang => {
            document.getElementById(`code-${lang}`).value = DEFAULTS[lang];
            const extraKeys = {
                'Ctrl-Space': 'autocomplete',
                'Tab': (cm) => handleTab(cm, lang)
            };
            if (lang === 'html') extraKeys['Ctrl-J'] = 'toMatchingTag';

            const editorConfig = {
                mode: modes[lang],
                lineNumbers: true,
                keyMap: 'vim',
                extraKeys,
                hintOptions: { completeSingle: false },
                autoCloseTags: true,
                autoCloseBrackets: true,
                matchTags: lang === 'html' ? { bothTags: true } : false
            };

            const cm = CodeMirror.fromTextArea(document.getElementById(`code-${lang}`), editorConfig);

            cm.on('inputRead', function(editor, change) {
                if (change.origin !== '+input') return;
                if (editor.state.completionActive) return;

                const lastChar = change.text[0];
                if (triggerChars[lang].includes(lastChar)) {
                    CodeMirror.commands.autocomplete(editor, null, { completeSingle: false });
                }
            });

            editors[lang] = cm;

            // Hide textarea initially (CodeMirror is active)
            document.getElementById(`code-${lang}`).style.display = 'none';
        });
    }

    function initFallback() {
        state.editorMode = 'plain';
        document.body.classList.add('offline-mode', 'plain-mode');

        PANELS.forEach(lang => {
            const textarea = document.getElementById(`code-${lang}`);
            textarea.value = DEFAULTS[lang];
            editors[lang] = createPlainEditor(lang);
        });
    }

    init();
    </script>
</body>
</html>
