<!--
  name: AeroCode
  description: CodePen with Frutiger Aero aesthetic
  author: Isaac Clayton (https://isaac.sh)
  tools: Zed, Gemini 3 Pro Preview, Claude Opus 4.5
  repo: https://github.com/slightknack/aerocode
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AeroCode</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/neat.min.css">
    <style>
        :root {
            --glass-border: 1px solid rgba(255, 255, 255, 0.6);
            --bg-grad: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            --sidebar-bg: rgba(255, 255, 255, 0.35);
            --header-height: 28px;
            --toolbar-height: 32px;
            --gap: 8px;
            --radius: 10px;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background:
                radial-gradient(circle at 10% 10%, rgba(255,255,255,0.8) 0%, transparent 40%),
                var(--bg-grad);
        }

        .hidden { display: none !important; }

        #drag-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            display: none;
        }

        .sidebar-strip, .preview-strip {
            width: 16px;
            height: 100vh;
            background: rgba(0, 120, 215, 0.6);
            cursor: col-resize;
            display: none;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        .sidebar-strip { border-right: 1px solid rgba(0, 120, 215, 0.8); }
        .preview-strip { border-left: 1px solid rgba(0, 120, 215, 0.8); flex-shrink: 0; }
        .sidebar-strip:hover, .preview-strip:hover { background: rgba(0, 120, 215, 0.8); }

        .sidebar {
            display: flex;
            flex-direction: column;
            background: var(--sidebar-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: var(--glass-border);
            padding: var(--gap);
            z-index: 10;
            position: relative;
            flex-shrink: 0;
        }

        .sidebar-resizer {
            position: absolute;
            top: 0;
            bottom: 0;
            right: -4px;
            width: 10px;
            cursor: col-resize;
            z-index: 50;
        }

        .editor-box {
            position: absolute;
            left: var(--gap);
            right: var(--gap);
            background: rgba(255, 255, 255, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.9);
            border-radius: var(--radius);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.03);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-header {
            height: var(--header-height);
            min-height: var(--header-height);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            background: linear-gradient(to bottom, #fff 0%, #f1f1f1 100%);
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            user-select: none;
            flex-shrink: 0;
        }

        .label {
            font-size: 11px;
            font-weight: 700;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 0 #fff;
        }

        .editor-content {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.5);
        }

        .controls { display: flex; gap: 6px; align-items: center; }

        .traffic-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        .traffic-btn svg { width: 8px; height: 8px; opacity: 0; }
        .traffic-btn:hover svg { opacity: 0.6; }
        .traffic-btn path { stroke: #000; stroke-width: 1.5; stroke-linecap: round; }

        .btn-yellow { background: #ffbd2e; border-color: #d6a12d; }
        .btn-green { background: #27c93f; border-color: #21a132; }
        .btn-red { background: #ff5f57; border-color: #e0443e; }

        .sidebar.fullscreen-mode .editor-box { display: none; }
        .sidebar.fullscreen-mode .editor-box.fs-active {
            display: flex;
            position: absolute;
            top: var(--gap) !important;
            bottom: calc(var(--toolbar-height) + var(--gap) + var(--gap)) !important;
            height: auto !important;
            z-index: 100;
        }
        .fullscreen-mode .label { display: none; }
        .fs-nav { display: none; align-items: center; gap: 4px; }
        .fullscreen-mode .fs-nav { display: flex; }

        .fs-tag {
            font-size: 10px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.05);
            padding: 3px 8px;
            border-radius: 12px;
            color: #666;
            cursor: pointer;
        }
        .fs-tag:hover { background: rgba(0, 0, 0, 0.1); color: #333; }
        .fs-tag.active { background: #0078d7; color: white; }

        .CodeMirror {
            position: absolute;
            inset: 0;
            height: 100% !important;
            background: transparent !important;
            font-family: 'Menlo', 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        .CodeMirror-gutters {
            background: rgba(245, 245, 245, 0.95) !important;
            border-right: 1px solid rgba(0, 0, 0, 0.06) !important;
        }

        .preview {
            flex: 1;
            min-width: 0;
            background: white;
            position: relative;
            overflow: hidden;
        }
        .preview iframe { width: 100%; height: 100%; border: none; }

        .bottom-toolbar {
            position: absolute;
            bottom: var(--gap);
            left: var(--gap);
            right: var(--gap);
            height: var(--toolbar-height);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0;
            z-index: 50;
        }

        .mode-switcher { display: flex; gap: 4px; }

        .mode-tag, .share-btn {
            font-size: 10px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.5);
            padding: 4px 10px;
            border-radius: 12px;
            color: #666;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.6);
        }
        .mode-tag:hover, .share-btn:hover { background: rgba(255, 255, 255, 0.7); color: #333; }
        .mode-tag.active { background: #0078d7; color: white; border-color: #0066b8; }
        .share-btn { background: #0078d7; color: white; border-color: #0066b8; }
        .share-btn:hover { background: #005a9e; color: white; }
        .share-btn.copied { background: rgba(255, 255, 255, 0.5); color: #666; border-color: rgba(255, 255, 255, 0.6); }
        .share-btn.copied:hover { background: rgba(255, 255, 255, 0.7); color: #333; }

        .copy-btn {
            font-size: 9px;
            color: #999;
            cursor: pointer;
            margin-left: 8px;
            opacity: 0.6;
        }
        .copy-btn:hover { opacity: 1; color: #666; }
        .copy-btn.copied { color: #0078d7; opacity: 1; }
    </style>
</head>
<body>
    <div id="drag-overlay"></div>
    <div id="sidebar-strip" class="sidebar-strip"></div>

    <div id="sidebar" class="sidebar">
        <div class="sidebar-resizer" id="sidebar-resizer"></div>

        <div class="editor-box" id="box-html">
            <div class="editor-header" id="header-html">
                <div style="display:flex;align-items:center">
                    <span class="label">HTML</span>
                    <div class="fs-nav">
                        <span class="fs-tag active" data-panel="html">HTML</span>
                        <span class="fs-tag" data-panel="css">CSS</span>
                        <span class="fs-tag" data-panel="js">JS</span>
                    </div>
                    <span class="copy-btn" data-lang="html">copy</span>
                </div>
                <div class="controls">
                    <div class="traffic-btn btn-yellow" data-action="minimize" data-panel="html">
                        <svg viewBox="0 0 10 10"><path d="M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-green" data-action="fullscreen" data-panel="html">
                        <svg viewBox="0 0 10 10"><path d="M5,2 L5,8 M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-red" data-action="exit-fullscreen" data-panel="html" style="display:none">
                        <svg viewBox="0 0 10 10"><path d="M2,2 L8,8 M8,2 L2,8"/></svg>
                    </div>
                </div>
            </div>
            <div class="editor-content"><textarea id="code-html"></textarea></div>
        </div>

        <div class="editor-box" id="box-css">
            <div class="editor-header" id="header-css">
                <div style="display:flex;align-items:center">
                    <span class="label">CSS</span>
                    <div class="fs-nav">
                        <span class="fs-tag" data-panel="html">HTML</span>
                        <span class="fs-tag active" data-panel="css">CSS</span>
                        <span class="fs-tag" data-panel="js">JS</span>
                    </div>
                    <span class="copy-btn" data-lang="css">copy</span>
                </div>
                <div class="controls">
                    <div class="traffic-btn btn-yellow" data-action="minimize" data-panel="css">
                        <svg viewBox="0 0 10 10"><path d="M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-green" data-action="fullscreen" data-panel="css">
                        <svg viewBox="0 0 10 10"><path d="M5,2 L5,8 M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-red" data-action="exit-fullscreen" data-panel="css" style="display:none">
                        <svg viewBox="0 0 10 10"><path d="M2,2 L8,8 M8,2 L2,8"/></svg>
                    </div>
                </div>
            </div>
            <div class="editor-content"><textarea id="code-css"></textarea></div>
        </div>

        <div class="editor-box" id="box-js">
            <div class="editor-header" id="header-js">
                <div style="display:flex;align-items:center">
                    <span class="label">JS</span>
                    <div class="fs-nav">
                        <span class="fs-tag" data-panel="html">HTML</span>
                        <span class="fs-tag" data-panel="css">CSS</span>
                        <span class="fs-tag active" data-panel="js">JS</span>
                    </div>
                    <span class="copy-btn" data-lang="js">copy</span>
                </div>
                <div class="controls">
                    <div class="traffic-btn btn-yellow" data-action="minimize" data-panel="js">
                        <svg viewBox="0 0 10 10"><path d="M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-green" data-action="fullscreen" data-panel="js">
                        <svg viewBox="0 0 10 10"><path d="M5,2 L5,8 M2,5 L8,5"/></svg>
                    </div>
                    <div class="traffic-btn btn-red" data-action="exit-fullscreen" data-panel="js" style="display:none">
                        <svg viewBox="0 0 10 10"><path d="M2,2 L8,8 M8,2 L2,8"/></svg>
                    </div>
                </div>
            </div>
            <div class="editor-content"><textarea id="code-js"></textarea></div>
        </div>

        <div class="bottom-toolbar">
            <div class="mode-switcher">
                <span class="mode-tag active" data-keymap="vim">VIM</span>
                <span class="mode-tag" data-keymap="default">NORMAL</span>
            </div>
            <div style="display: flex; gap: 4px;">
                <div class="share-btn" id="new-btn">NEW</div>
                <div class="share-btn" id="share-btn">SHARE</div>
            </div>
        </div>
    </div>

    <div id="preview-strip" class="preview-strip"></div>
    <div class="preview"><iframe id="preview-frame"></iframe></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/keymap/vim.min.js"></script>

    <script>
    // Layout constants
    const PANELS = ['html', 'css', 'js'];
    const HEADER_H = 28;
    const MIN_H = 50;       // min panel height when open (header + 1.5 lines)
    const COLLAPSED_H = HEADER_H;
    const GAP = 8;
    const TOOLBAR_H = 32 + GAP;
    const MIN_SIDEBAR_W = 300;
    const STRIP_W = 16;

    const DEFAULTS = {
        html: `<div class="wrapper">\n  <button class="gel-btn">Download<br>Aerocode</button>\n</div>`,
        css: `body {\n  height: 100vh; margin: 0;\n  display: flex; justify-content: center; align-items: center;\n  background-image:\n    linear-gradient(#eee 1px, transparent 1px),\n    linear-gradient(90deg, #eee 1px, transparent 1px);\n  background-size: 20px 20px;\n  background-color: #fafafa;\n}\n\n.gel-btn {\n  font-family: -apple-system, sans-serif;\n  font-weight: 600; font-size: 14px;\n  color: #fff; text-shadow: 0 -1px 0 rgba(0,0,0,0.2);\n  padding: 8px 30px;\n  border: 1px solid #2e6da4; border-radius: 100px;\n  background: linear-gradient(to bottom, #7bbaf7 0%, #4096ee 100%);\n  box-shadow: 0 2px 5px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.4);\n  cursor: pointer;\n}\n\n.gel-btn:hover { filter: brightness(1.05); }`,
        js: `document.querySelector('.gel-btn')?.addEventListener('click', () => {\n  const a = document.createElement('a');\n  a.href = 'https://slightknack.dev/aerocode.html';\n  a.download = 'aerocode.html';\n  a.click();\n});`
    };

    // Application state (declarative model)
    const state = {
        sidebarWidth: 350,
        prevSidebarWidth: 350,
        collapsed: false,
        fullscreen: null,
        minimized: { html: false, css: false, js: false },
        heights: { html: 200, css: 200, js: 200 },
        clipboard: null  // { type: 'share' | 'copy', lang?: string } or null
    };

    const dom = {};
    const editors = {};

    // Geometry helpers
    function getUsableHeight() {
        return dom.sidebar.clientHeight - TOOLBAR_H;
    }

    function getEffectiveHeight(panel) {
        return state.minimized[panel] ? COLLAPSED_H : state.heights[panel];
    }

    // Ensure panels fit within available space
    function enforceConstraints() {
        const usable = getUsableHeight();
        const totalGaps = (PANELS.length + 1) * GAP;
        const availableForPanels = usable - totalGaps;

        const openPanels = PANELS.filter(p => !state.minimized[p]);
        const minimizedCount = PANELS.length - openPanels.length;
        const spaceForOpen = availableForPanels - minimizedCount * COLLAPSED_H;

        if (openPanels.length === 0) return;

        let currentOpenTotal = openPanels.reduce((sum, p) => sum + state.heights[p], 0);

        if (currentOpenTotal > spaceForOpen) {
            // Shrink proportionally when too big
            const scale = spaceForOpen / currentOpenTotal;
            openPanels.forEach(p => {
                state.heights[p] = Math.max(MIN_H, Math.floor(state.heights[p] * scale));
            });
        } else if (currentOpenTotal < spaceForOpen) {
            // Grow proportionally when there's extra space
            const extra = spaceForOpen - currentOpenTotal;
            const perPanel = Math.floor(extra / openPanels.length);
            openPanels.forEach(p => {
                state.heights[p] += perPanel;
            });
        }
    }

    function initializeHeights() {
        const usable = getUsableHeight();
        const totalGaps = (PANELS.length + 1) * GAP;
        const heightPerPanel = Math.floor((usable - totalGaps) / PANELS.length);
        PANELS.forEach(p => { state.heights[p] = heightPerPanel; });
    }

    // Render: derive DOM from state
    function render() {
        const maxW = window.innerWidth;

        if (state.collapsed) {
            dom.sidebar.classList.add('hidden');
            dom.strip.style.display = 'block';
            dom.previewStrip.style.display = 'none';
            return;
        }

        dom.sidebar.classList.remove('hidden');
        dom.strip.style.display = 'none';
        dom.sidebar.style.width = `${state.sidebarWidth}px`;

        dom.previewStrip.style.display = (state.sidebarWidth >= maxW - STRIP_W - 10) ? 'block' : 'none';

        if (state.fullscreen) {
            dom.sidebar.classList.add('fullscreen-mode');
            PANELS.forEach(p => {
                const box = dom.boxes[p];
                const isActive = p === state.fullscreen;
                box.classList.toggle('fs-active', isActive);
                box.querySelector('.btn-red').style.display = isActive ? 'flex' : 'none';
                box.querySelector('.btn-green').style.display = isActive ? 'none' : 'flex';
                box.querySelector('.btn-yellow').style.display = isActive ? 'none' : 'flex';
            });
        } else {
            dom.sidebar.classList.remove('fullscreen-mode');

            let top = GAP;
            PANELS.forEach(p => {
                const h = getEffectiveHeight(p);
                const box = dom.boxes[p];

                box.classList.remove('fs-active');
                box.style.top = `${top}px`;
                box.style.height = `${h}px`;
                box.style.bottom = 'auto';

                box.querySelector('.btn-red').style.display = 'none';
                box.querySelector('.btn-green').style.display = 'flex';
                box.querySelector('.btn-yellow').style.display = 'flex';

                document.getElementById(`header-${p}`).style.cursor = p === 'html' ? 'pointer' : 'row-resize';

                top += h + GAP;
            });
        }

        requestAnimationFrame(() => {
            Object.values(editors).forEach(cm => cm.refresh());
        });

        // Clipboard button states
        const shareBtn = document.getElementById('share-btn');
        if (state.clipboard?.type === 'share') {
            shareBtn.classList.add('copied');
            shareBtn.textContent = 'COPIED URL';
        } else {
            shareBtn.classList.remove('copied');
            shareBtn.textContent = 'SHARE';
        }

        document.querySelectorAll('.copy-btn').forEach(btn => {
            const lang = btn.dataset.lang;
            if (state.clipboard?.type === 'copy' && state.clipboard.lang === lang) {
                btn.textContent = 'copied!';
                btn.classList.add('copied');
            } else {
                btn.textContent = 'copy';
                btn.classList.remove('copied');
            }
        });
    }

    // Panel actions
    function toggleMinimize(panel) {
        const idx = PANELS.indexOf(panel);

        if (!state.minimized[panel]) {
            const freedSpace = state.heights[panel] - COLLAPSED_H;
            state.minimized[panel] = true;

            let recipient = PANELS.slice(idx + 1).find(p => !state.minimized[p]);
            if (!recipient) recipient = PANELS.slice(0, idx).reverse().find(p => !state.minimized[p]);
            if (recipient) state.heights[recipient] += freedSpace;
        } else {
            const neededSpace = state.heights[panel] - COLLAPSED_H;
            state.minimized[panel] = false;

            const othersOpen = PANELS.filter(p => p !== panel && !state.minimized[p]);
            if (othersOpen.length === 0) {
                const usable = getUsableHeight();
                const totalGaps = (PANELS.length + 1) * GAP;
                state.heights[panel] = usable - totalGaps - (PANELS.length - 1) * COLLAPSED_H;
            } else {
                let remaining = neededSpace;
                for (const p of PANELS.slice(idx + 1)) {
                    if (state.minimized[p] || remaining <= 0) continue;
                    const canTake = Math.min(remaining, state.heights[p] - MIN_H);
                    state.heights[p] -= canTake;
                    remaining -= canTake;
                }
                for (const p of PANELS.slice(0, idx).reverse()) {
                    if (state.minimized[p] || remaining <= 0) continue;
                    const canTake = Math.min(remaining, state.heights[p] - MIN_H);
                    state.heights[p] -= canTake;
                    remaining -= canTake;
                }
            }
        }
        render();
    }

    function toggleFullscreen(panel) {
        state.fullscreen = (state.fullscreen === panel) ? null : panel;
        if (state.fullscreen) state.minimized[panel] = false;
        render();
    }

    function switchFullscreenPanel(panel) {
        if (state.fullscreen) {
            state.fullscreen = panel;
            render();
        }
    }

    // Drag computation: panels exchange space, no auto-collapse
    function computeDragState(startState, draggedPanel, delta) {
        const panelIdx = PANELS.indexOf(draggedPanel);
        const newState = {
            minimized: { ...startState.minimized },
            heights: { ...startState.heights }
        };

        const hasOpenPanelAbove = PANELS.slice(0, panelIdx).some(p => !startState.minimized[p]);

        if (delta < 0) {
            if (!hasOpenPanelAbove) return newState;

            let growAmount = -delta;

            for (let i = panelIdx - 1; i >= 0 && growAmount > 0; i--) {
                const p = PANELS[i];
                if (newState.minimized[p]) continue;

                const canShrink = newState.heights[p] - MIN_H;
                const shrink = Math.min(canShrink, growAmount);
                newState.heights[p] -= shrink;
                growAmount -= shrink;
            }

            const actualGrow = -delta - growAmount;
            if (!startState.minimized[draggedPanel]) {
                newState.heights[draggedPanel] += actualGrow;
            }
        } else if (delta > 0) {
            if (!hasOpenPanelAbove) return newState;

            if (!startState.minimized[draggedPanel]) {
                const canShrink = startState.heights[draggedPanel] - MIN_H;
                const shrink = Math.min(canShrink, delta);
                newState.heights[draggedPanel] = startState.heights[draggedPanel] - shrink;

                for (let i = panelIdx - 1; i >= 0; i--) {
                    const p = PANELS[i];
                    if (newState.minimized[p]) continue;
                    newState.heights[p] += shrink;
                    break;
                }
            }
        }

        return newState;
    }

    // Event binding
    function bindEvents() {
        dom.resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const startWidth = state.sidebarWidth;

            startDrag('col-resize', (em) => {
                const newW = em.clientX;
                const maxW = window.innerWidth;

                if (newW < 50) {
                    state.prevSidebarWidth = startWidth;
                    state.collapsed = true;
                } else if (newW > maxW - 30) {
                    state.prevSidebarWidth = startWidth;
                    state.sidebarWidth = maxW - STRIP_W;
                } else {
                    state.sidebarWidth = Math.max(MIN_SIDEBAR_W, newW);
                }
                render();
            });
        });

        bindStripDrag(dom.strip, () => {
            state.collapsed = false;
            state.sidebarWidth = state.prevSidebarWidth;
            render();
        });

        bindStripDrag(dom.previewStrip, () => {
            const maxW = window.innerWidth;
            if (state.prevSidebarWidth >= maxW - STRIP_W - 10) {
                state.sidebarWidth = Math.min(350, maxW * 0.4);
            } else {
                state.sidebarWidth = state.prevSidebarWidth;
            }
            render();
        });

        PANELS.forEach(panel => {
            const header = document.getElementById(`header-${panel}`);
            header.addEventListener('mousedown', (e) => {
                if (e.target.closest('.controls') || e.target.closest('.fs-nav') || e.target.closest('.copy-btn')) return;
                e.preventDefault();

                if (panel === 'html') {
                    toggleMinimize('html');
                    return;
                }

                const startY = e.clientY;
                const startState = {
                    minimized: { ...state.minimized },
                    heights: { ...state.heights }
                };
                let isDrag = false;

                startDrag('row-resize', (em) => {
                    const delta = em.clientY - startY;
                    if (Math.abs(delta) > 3) isDrag = true;
                    if (!isDrag) return;

                    const newState = computeDragState(startState, panel, delta);
                    state.minimized = newState.minimized;
                    state.heights = newState.heights;
                    enforceConstraints();
                    render();
                }, () => {
                    if (!isDrag) toggleMinimize(panel);
                });
            });
        });

        document.querySelectorAll('.traffic-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const action = btn.dataset.action;
                const panel = btn.dataset.panel;
                if (action === 'minimize') toggleMinimize(panel);
                else if (action === 'fullscreen' || action === 'exit-fullscreen') toggleFullscreen(panel);
            });
        });

        document.querySelectorAll('.fs-tag').forEach(tag => {
            tag.addEventListener('click', (e) => {
                e.stopPropagation();
                switchFullscreenPanel(tag.dataset.panel);
            });
        });

        document.querySelectorAll('.copy-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                e.stopPropagation();
                const lang = btn.dataset.lang;
                const text = editors[lang].getValue();

                try {
                    await navigator.clipboard.writeText(text);
                } catch (err) {
                    const tmp = document.createElement('textarea');
                    tmp.value = text;
                    tmp.style.position = 'fixed';
                    tmp.style.opacity = '0';
                    document.body.appendChild(tmp);
                    tmp.focus();
                    tmp.select();
                    document.execCommand('copy');
                    document.body.removeChild(tmp);
                }

                state.clipboard = { type: 'copy', lang };
                render();
            });
        });

        document.querySelectorAll('.mode-tag').forEach(tag => {
            tag.addEventListener('click', () => {
                const keymap = tag.dataset.keymap;
                Object.values(editors).forEach(cm => cm.setOption('keyMap', keymap));
                document.querySelectorAll('.mode-tag').forEach(t => t.classList.remove('active'));
                tag.classList.add('active');
            });
        });

        document.getElementById('new-btn').addEventListener('click', () => {
            if (!confirm('Clear all code and start fresh?')) return;

            editors.html.setValue('');
            editors.css.setValue('');
            editors.js.setValue('');

            state.collapsed = false;
            state.fullscreen = null;
            state.minimized = { html: false, css: false, js: false };
            state.clipboard = null;
            initializeHeights();

            history.replaceState(null, '', location.pathname);

            render();
            updatePreview();
        });

        document.getElementById('share-btn').addEventListener('click', async () => {
            await updateUrl();
            const url = window.location.href;

            try {
                await navigator.clipboard.writeText(url);
            } catch (err) {
                const tmp = document.createElement('textarea');
                tmp.value = url;
                tmp.style.position = 'fixed';
                tmp.style.opacity = '0';
                document.body.appendChild(tmp);
                tmp.focus();
                tmp.select();
                document.execCommand('copy');
                document.body.removeChild(tmp);
            }

            state.clipboard = { type: 'share' };
            render();
        });

        window.addEventListener('resize', () => {
            enforceConstraints();
            render();
        });
    }

    function startDrag(cursor, onMove, onUp = () => {}) {
        dom.overlay.style.display = 'block';
        dom.overlay.style.cursor = cursor;
        document.body.style.cursor = cursor;

        const moveHandler = (em) => onMove(em);
        const upHandler = () => {
            window.removeEventListener('mousemove', moveHandler);
            window.removeEventListener('mouseup', upHandler);
            dom.overlay.style.display = 'none';
            document.body.style.cursor = '';
            onUp();
        };

        window.addEventListener('mousemove', moveHandler);
        window.addEventListener('mouseup', upHandler);
    }

    function bindStripDrag(strip, onClickRestore) {
        strip.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const startX = e.clientX;
            const startWidth = state.collapsed ? state.prevSidebarWidth : state.sidebarWidth;
            let isDrag = false;

            startDrag('col-resize', (em) => {
                if (Math.abs(em.clientX - startX) > 3) isDrag = true;
                if (!isDrag) return;

                const newW = em.clientX;
                const maxW = window.innerWidth;

                if (newW < 50) {
                    state.prevSidebarWidth = startWidth || 350;
                    state.collapsed = true;
                } else {
                    state.collapsed = false;
                    state.sidebarWidth = (newW > maxW - 30) ? maxW - STRIP_W : Math.max(MIN_SIDEBAR_W, newW);
                }
                render();
            }, () => {
                if (!isDrag) onClickRestore();
            });
        });
    }

    // Preview and URL state
    let urlTimeout = null;

    function updatePreview() {
        const html = editors.html.getValue();
        const css = `<style>${editors.css.getValue()}</style>`;
        const js = `<script>${editors.js.getValue()}<\/script>`;
        const doc = dom.preview.contentDocument || dom.preview.contentWindow.document;
        doc.open();
        doc.write(html + css + js);
        doc.close();

        scheduleUrlUpdate();
    }

    function scheduleUrlUpdate() {
        clearTimeout(urlTimeout);
        urlTimeout = setTimeout(updateUrl, 500);
    }

    async function updateUrl() {
        try {
            const data = {
                h: editors.html.getValue(),
                c: editors.css.getValue(),
                j: editors.js.getValue(),
                s: state.collapsed ? 0 : 1,
                f: state.fullscreen || ''
            };
            const json = JSON.stringify(data);
            const compressed = await new Response(new Blob([json]).stream().pipeThrough(new CompressionStream('gzip'))).arrayBuffer();
            const encoded = btoa(String.fromCharCode(...new Uint8Array(compressed)));
            history.replaceState(null, '', `${location.pathname}#${encoded}`);
        } catch (err) {}
    }

    async function loadFromHash() {
        const hash = location.hash.slice(1);
        if (!hash) return;
        try {
            const bytes = Uint8Array.from(atob(hash), c => c.charCodeAt(0));
            const json = await new Response(new Blob([bytes]).stream().pipeThrough(new DecompressionStream('gzip'))).text();
            const data = JSON.parse(json);

            if (data.h !== undefined) editors.html.setValue(data.h);
            if (data.c !== undefined) editors.css.setValue(data.c);
            if (data.j !== undefined) editors.js.setValue(data.j);

            if (data.s !== undefined) state.collapsed = data.s === 0;
            if (data.f !== undefined) state.fullscreen = data.f || null;

            render();
        } catch (e) {}
    }

    // Init
    function init() {
        dom.sidebar = document.getElementById('sidebar');
        dom.strip = document.getElementById('sidebar-strip');
        dom.previewStrip = document.getElementById('preview-strip');
        dom.overlay = document.getElementById('drag-overlay');
        dom.preview = document.getElementById('preview-frame');
        dom.resizer = document.getElementById('sidebar-resizer');
        dom.boxes = {
            html: document.getElementById('box-html'),
            css: document.getElementById('box-css'),
            js: document.getElementById('box-js')
        };

        const modes = { html: 'htmlmixed', css: 'css', js: 'javascript' };
        PANELS.forEach(lang => {
            document.getElementById(`code-${lang}`).value = DEFAULTS[lang];
            const cm = CodeMirror.fromTextArea(document.getElementById(`code-${lang}`), {
                mode: modes[lang],
                theme: 'neat',
                lineNumbers: true,
                keyMap: 'vim'
            });
            cm.on('change', () => {
                updatePreview();
                if (state.clipboard !== null) {
                    state.clipboard = null;
                    render();
                }
            });
            editors[lang] = cm;
        });

        initializeHeights();
        bindEvents();
        updatePreview();
        render();
        loadFromHash();
    }

    init();
    </script>
</body>
</html>
